import sys
import os
import re
import logging
import hashlib
import shutil
import traceback
import time  # 新增导入

# Add the project root directory to Python path
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(current_dir)
sys.path.append(os.path.join(current_dir, "GPT_SoVITS"))

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QFrame, QGroupBox,
    QLabel, QPushButton, QFileDialog, QTextEdit, QLineEdit, QComboBox,
    QMessageBox, QGridLayout, QTableWidget, QHeaderView, QCheckBox,
    QScrollArea, QTableWidgetItem, QSlider, QSizePolicy, QStackedLayout,
    QWidget, QStackedWidget, QSpinBox, QDoubleSpinBox, QProgressBar, 
    QRadioButton, QProgressDialog)
from PyQt6.QtCore import (
    Qt, QUrl, QSize, QPoint, QTimer, QSettings
)
from PyQt6.QtGui import QColor, QPalette, QIcon, QFont, QTextCharFormat, QTextCursor
from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput, QMediaDevices
from text_processor import TextProcessor
from gpt_sovits import GPTSoVITS
from preset_manager import PresetManager
from preset_order_manager import PresetOrderManager
from model_cache import get_global_model_cache
from swipe_selector import SwipeSelector
from typing import List, Dict, Optional, Tuple
import jieba

logger = logging.getLogger(__name__)

class ReplaceHistoryManager:
    """管理替换历史记录，支持持久化到文件"""
    
    def __init__(self):
        """初始化替换历史管理器"""
        self.replace_history = {}
        self.history_file = os.path.join(current_dir, "replace_history.txt")
        self.load_from_file()
    
    def add_replace_record(self, search_text: str, replace_text: str):
        """添加替换记录"""
        if not search_text:
            return
        
        # 添加到历史中
        self.replace_history[search_text] = replace_text
        
        # 保存到文件
        self.save_to_file()
    
    def delete_replace_record(self, search_text: str):
        """删除替换记录"""
        if search_text in self.replace_history:
            del self.replace_history[search_text]
            self.save_to_file()
    
    def get_all_history(self) -> Dict[str, str]:
        """获取所有替换历史"""
        return self.replace_history
    
    def apply_all_replacements(self, text: str) -> str:
        """应用所有替换规则到给定文本"""
        if not text or not self.replace_history:
            return text
            
        result = text
        for search_text, replace_text in self.replace_history.items():
            result = result.replace(search_text, replace_text)
            
        return result
    
    def save_to_file(self):
        """保存替换历史到文件"""
        try:
            with open(self.history_file, 'w', encoding='utf-8') as f:
                # 使用简单的格式："原文-替换文本/原文-替换文本"
                replacements = []
                for search_text, replace_text in self.replace_history.items():
                    replacements.append(f"{search_text}-{replace_text}")
                
                f.write("/".join(replacements))
                
            logger.info(f"成功保存替换历史到文件: {self.history_file}")
        except Exception as e:
            logger.error(f"保存替换历史到文件失败: {str(e)}")
    
    def load_from_file(self):
        """从文件加载替换历史"""
        if not os.path.exists(self.history_file):
            logger.info(f"替换历史文件不存在，将创建新文件: {self.history_file}")
            return
            
        try:
            with open(self.history_file, 'r', encoding='utf-8') as f:
                content = f.read().strip()
                
                if not content:
                    return
                    
                # 解析文件内容
                replacements = content.split('/')
                for replacement in replacements:
                    if '-' in replacement:
                        parts = replacement.split('-', 1)  # 使用1确保只分割第一个'-'
                        if len(parts) == 2:
                            search_text, replace_text = parts
                            self.replace_history[search_text] = replace_text
                
            logger.info(f"成功从文件加载替换历史: {self.history_file}")
            logger.info(f"加载了 {len(self.replace_history)} 条替换规则")
        except Exception as e:
            logger.error(f"从文件加载替换历史失败: {str(e)}")

# 创建全局替换历史管理器实例
replace_history_manager = ReplaceHistoryManager()

class StyleSheet:
    MAIN_STYLE = """
    QMainWindow {
        background-color: #faf6f1;
    }
    
    QPushButton {
        background-color: #C5D8EC;
        border: 1px solid #d4c5b9;
        border-radius: 6px;
        padding: 6px 12px;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        font-weight: 500;
    }
    
    QPushButton:hover {
        background-color: #B5C8DC;
        border-color: #c4b5a9;
    }
    
    QPushButton#generate_btn {
        background-color: #C67A8A;
        color: white;
        border: none;
    }
    
    QPushButton#generate_btn:hover {
        background-color: #B56A7A;
    }
    
    QLabel {
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        font-weight: 450;
        letter-spacing: 0.2px;
    }
    
    QComboBox {
        background-color: #faf6f1;
        border: 1px solid #d4c5b9;
        border-radius: 6px;
        padding: 5px 8px;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        font-weight: 450;
        min-width: 120px;
    }
    
    QComboBox:hover {
        border-color: #c4b5a9;
        background-color: #f7f3ee;
    }

    QComboBox:focus {
        border-color: #C67A8A;
    }
    
    QComboBox::drop-down {
        border: none;
        width: 30px;
    }
    
    QComboBox::down-arrow {
        image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTQgNkw4IDEwTDEyIDYiIHN0cm9rZT0iIzRhNTU2OCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+);
        width: 16px;
        height: 16px;
    }

    QComboBox::down-arrow:hover {
        image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTQgNkw4IDEwTDEyIDYiIHN0cm9rZT0iI0QwNUE2RSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+);
    }

    QComboBox QAbstractItemView {
        background-color: #faf6f1;
        border: 2px solid #d4c5b9;
        border-radius: 10px;
        padding: 4px;
        selection-background-color: #f7f3ee;
        selection-color: #4a5568;
    }

    QComboBox QAbstractItemView::item {
        background-color: #faf6f1;
        color: #4a5568;
        padding: 8px 12px;
        margin: 2px;
        border-radius: 6px;
        min-height: 20px;
    }

    QComboBox QAbstractItemView::item:hover {
        background-color: #f7f3ee;
    }

    QComboBox QAbstractItemView::item:selected {
        background-color: #f0ece7;
    }

    /* 移除滚动条 */
    QComboBox QScrollBar:vertical {
        width: 0px;
        background: transparent;
    }

    /* 确保下拉框打开时的样式 */
    QComboBox:on {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        border-color: #C67A8A;
    }

    QComboBox::drop-down:on {
        border: none;
    }

    /* 下拉列表的样式 */
    QListView {
        background-color: #faf6f1;
        outline: none;
        border: none;
    }

    QListView::item {
        background-color: #faf6f1;
        color: #4a5568;
    }

    QListView::item:hover {
        background-color: #f7f3ee;
    }

    QListView::item:selected {
        background-color: #f0ece7;
        color: #4a5568;
    }

    QTextEdit {
        background-color: #ffffff;
        border: 1px solid #d4c5b9;
        border-radius: 6px;
        padding: 5px;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        selection-background-color: #C5D8EC;
        selection-color: #4a5568;
    }

    QTextEdit:focus {
        border-color: #C67A8A;
    }

    /* 添加滚动条样式 */
    QTextEdit QScrollBar:vertical {
        border: none;
        background: #f0f0f0;
        width: 10px;
        border-radius: 5px;
    }

    QTextEdit QScrollBar::handle:vertical {
        background: #C67A8A;
        border-radius: 5px;
        min-height: 20px;
    }

    QTextEdit QScrollBar::add-line:vertical,
    QTextEdit QScrollBar::sub-line:vertical {
        height: 0px;
    }

    QTextEdit QScrollBar::add-page:vertical,
    QTextEdit QScrollBar::sub-page:vertical {
        background: none;
    }

    QDoubleSpinBox {
        background-color: #ffffff;
        border: 1px solid #d4c5b9;
        border-radius: 4px;
        padding: 3px 5px;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        min-width: 80px;
        min-height: 30px;
    }

    QDoubleSpinBox:hover {
        border-color: #c4b5a9;
        background-color: #fafafa;
    }

    QDoubleSpinBox:focus {
        border-color: #C67A8A;
    }

    QDoubleSpinBox::up-button {
        border: none;
        background-color: transparent;
        width: 20px;
        padding-right: 2px;
        image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIgOEw2IDRMMTAgOCIgc3Ryb2tlPSIjNGE1NTY4IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4=);
    }

    QDoubleSpinBox::down-button {
        border: none;
        background-color: transparent;
        width: 20px;
        padding-right: 2px;
        image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIgNEw2IDhMMTAgNCIgc3Ryb2tlPSIjNGE1NTY4IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4=);
    }

    QDoubleSpinBox::up-button:hover, QDoubleSpinBox::down-button:hover {
        background-color: #C5D8EC;
        border-radius: 4px;
    }

    QDoubleSpinBox::up-button:pressed, QDoubleSpinBox::down-button:pressed {
        background-color: #B5C8DC;
    }
    
    .card {
        background-color: #ffffff;
        border-radius: 16px;
        padding: 24px;
        border: 1px solid #f0f0f0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    QProgressBar {
        background-color: #ffffff;
        border: 2px solid #d4c5b9;
        border-radius: 10px;
        text-align: center;
        color: #4a5568;
        font-size: 12px;
        min-height: 24px;
        max-height: 24px;
        padding: 0px;
    }

    QProgressBar::chunk {
        background-color: #C67A8A;
        border-radius: 8px;
        margin: 2px;
    }

    QLineEdit {
        background-color: #ffffff;
        border: 1px solid #d4c5b9;
        border-radius: 6px;
        padding: 5px;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        min-height: 30px;
    }

    QLineEdit:hover {
        border-color: #c4b5a9;
        background-color: #fafafa;
    }

    QLineEdit:focus {
        border-color: #C67A8A;
    }

    QSpinBox {
        background-color: #ffffff;
        border: 1px solid #d4c5b9;
        border-radius: 4px;
        padding: 3px 5px;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        min-width: 80px;
        min-height: 30px;
    }

    QSpinBox:hover {
        border-color: #c4b5a9;
        background-color: #fafafa;
    }

    QSpinBox:focus {
        border-color: #C67A8A;
    }

    QSpinBox::up-button {
        border: none;
        background-color: transparent;
        width: 20px;
        padding-right: 2px;
        image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIgOEw2IDRMMTAgOCIgc3Ryb2tlPSIjNGE1NTY4IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4=);
    }

    QSpinBox::down-button {
        border: none;
        background-color: transparent;
        width: 20px;
        padding-right: 2px;
        image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIgNEw2IDhMMTAgNCIgc3Ryb2tlPSIjNGE1NTY4IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4=);
    }

    QSpinBox::up-button:hover, QSpinBox::down-button:hover {
        background-color: #C5D8EC;
        border-radius: 4px;
    }

    QSpinBox::up-button:pressed, QSpinBox::down-button:pressed {
        background-color: #B5C8DC;
    }

    QGroupBox {
        border: 1px solid #d4c5b9;
        border-radius: 8px;
        margin-top: 0.8em;
        padding: 8px;
        color: #4a5568;
        font-weight: bold;
    }



    QCheckBox {
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        spacing: 4px;
    }

    QCheckBox::indicator {
        width: 14px;
        height: 14px;
        border: 1px solid #d4c5b9;
        border-radius: 3px;
        background-color: #ffffff;
    }

    QCheckBox::indicator:hover {
        border-color: #c4b5a9;
        background-color: #fafafa;
    }

    QCheckBox::indicator:checked {
        background-color: #C67A8A;
        border-color: #C67A8A;
        image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIgNkw1IDlMMTAgMyIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+);
    }

    QRadioButton {
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        spacing: 4px;
    }

    QRadioButton::indicator {
        width: 14px;
        height: 14px;
        border: 1px solid #d4c5b9;
        border-radius: 10px;
        background-color: #ffffff;
    }

    QRadioButton::indicator:hover {
        border-color: #c4b5a9;
        background-color: #fafafa;
    }

    QRadioButton::indicator:checked {
        background-color: #C67A8A;
        border-color: #C67A8A;
        width: 10px;
        height: 10px;
        margin: 4px;
    }

    /* 修改进度条样式 */
    QSlider::groove:horizontal {
        border: none;
        height: 4px;
        background: #C5D8EC;  /* 浅蓝色背景 */
        margin: 2px 0;
    }

    QSlider::handle:horizontal {
        background: #C67A8A;  /* 强调色手柄 */
        border: none;
        width: 12px;
        height: 12px;
        margin: -4px 0;
        border-radius: 6px;
    }

    QSlider::sub-page:horizontal {
        background: #C67A8A;  /* 强调色已播放部分 */
        border-radius: 2px;
    }

    QSlider::add-page:horizontal {
        background: #C5D8EC;  /* 浅蓝色未播放部分 */
        border-radius: 2px;
    }

    QSlider::handle:horizontal:hover {
        background: #B56A7A;  /* 手柄hover时的颜色 */
    }

    /* 🔧 添加QTableWidget样式，解决黑色背景问题 */
    QTableWidget {
        background-color: transparent;  /* 透明背景显示底层白色卡片 */
        alternate-background-color: #faf6f1;
        selection-background-color: #C5D8EC;
        selection-color: #4a5568;
        border: none;  /* 移除边框让背景透明 */
        border-radius: 8px;
        gridline-color: #e5e5e5;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
    }

    QTableWidget::item {
        background-color: transparent;  /* 透明背景 */
        color: #4a5568;
        border: none;
        padding: 8px;
    }

    QTableWidget::item:alternate {
        background-color: #faf6f1;
    }

    QTableWidget::item:selected {
        background-color: #C5D8EC;
        color: #4a5568;
    }

    QTableWidget::item:hover {
        background-color: #f7f3ee;
    }

    /* 🔧 修复选中行的悬停效果 - 选中状态优先级更高 */
    QTableWidget::item:selected:hover {
        background-color: #C5D8EC;  /* 选中行悬停时保持蓝色 */
        color: #4a5568;
    }

    QTableWidget QAbstractItemView {
        background-color: transparent;  /* 视图背景透明 */
        selection-background-color: #C5D8EC;
        selection-color: #4a5568;
    }

    QTableWidget QHeaderView::section {
        background-color: transparent;  /* 表头背景透明 */
        color: #4a5568;
        padding: 8px;
        border: none;
        border-bottom: 1px solid #d4c5b9;
        font-weight: 500;
    }

    QTableWidget QHeaderView::section:hover {
        background-color: #f7f3ee;
    }

    /* 🔧 处理表格左上角交汇处的"黑块"问题 */
    QTableWidget QTableCornerButton::section {
        background-color: transparent;  /* 左上角透明 */
        border: none;
    }

    /* 🔧 表格单元格容器样式 - 去掉黑色边框 */
    QWidget#cell-widget-container {
        background-color: transparent;
        border: none;
    }

    /* 🔧 优化QComboBox样式 - 设置固定高度和居中对齐 */
    QComboBox {
        background-color: #faf6f1 !important;
        border: 1px solid #d4c5b9 !important;
        border-radius: 6px !important;
        padding-left: 8px !important;
        padding-right: 8px !important;  /* 右边距保持一致，因为已隐藏下拉按钮 */
        padding-top: 4px !important;    /* 增加顶部内边距改善垂直居中 */
        padding-bottom: 4px !important; /* 增加底部内边距改善垂直居中 */
        height: 28px !important;        /* 设置固定高度 */
        max-height: 28px !important;    /* 确保高度固定 */
        min-height: 28px !important;    /* 确保最小高度 */
        color: #4a5568 !important;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif !important;
        font-size: 11px !important;
        text-align: left !important;    /* 文字左对齐 */
        line-height: 20px !important;   /* 设置行高改善文字垂直居中 */
    }

    /* 🔧 表格中的QComboBox特定样式 - 确保生效并优化对齐 */
    QTableWidget QComboBox, 
    QWidget#cell-widget-container QComboBox {
        background-color: #faf6f1 !important;
        border: 1px solid #d4c5b9 !important;
        border-radius: 6px !important;
        padding-left: 8px !important;
        padding-right: 8px !important;
        padding-top: 4px !important;    /* 与全局样式一致 */
        padding-bottom: 4px !important; /* 与全局样式一致 */
        height: 28px !important;
        max-height: 28px !important;
        min-height: 28px !important;
        color: #4a5568 !important;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif !important;
        font-size: 11px !important;
        text-align: left !important;
        line-height: 20px !important;
    }

    QComboBox:hover, 
    QTableWidget QComboBox:hover, 
    QWidget#cell-widget-container QComboBox:hover {
        background-color: #f7f3ee !important;
        border-color: #C67A8A !important;
    }

    QComboBox:focus, 
    QTableWidget QComboBox:focus, 
    QWidget#cell-widget-container QComboBox:focus {
        border-color: #C67A8A !important;
        outline: none !important;
    }

    /* 🔧 完全隐藏下拉按钮区域 - 去掉黑色小长方块 */
    QComboBox::drop-down, 
    QTableWidget QComboBox::drop-down, 
    QWidget#cell-widget-container QComboBox::drop-down {
        border: none !important;
        background: transparent !important;
        width: 0px !important;  /* 设置为0宽度完全隐藏 */
    }

    QComboBox::down-arrow, 
    QTableWidget QComboBox::down-arrow, 
    QWidget#cell-widget-container QComboBox::down-arrow {
        image: none !important;
        border: none !important;
        background: transparent !important;
        width: 0 !important;
        height: 0 !important;
    }

    /* 🔧 下拉菜单样式 - 解决变黑问题 */
    QComboBox QAbstractItemView {
        background-color: #faf6f1;  /* 米白色背景 */
        border: 1px solid #d4c5b9;
        border-radius: 6px;
        selection-background-color: #C5D8EC;  /* 淡蓝色选中 */
        selection-color: #4a5568;
        color: #4a5568;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        font-size: 11px;
        padding: 2px;
    }

    QComboBox QAbstractItemView::item {
        background-color: #faf6f1;  /* 米白色背景 */
        color: #4a5568;
        padding: 6px 12px;
        border: none;
        min-height: 24px;
    }

    QComboBox QAbstractItemView::item:hover {
        background-color: #f7f3ee;  /* 悬浮时的浅色 */
        color: #4a5568;
    }

    QComboBox QAbstractItemView::item:selected {
        background-color: #C5D8EC;  /* 选中时的淡蓝色 */
        color: #4a5568;
    }

    /* 🔧 区域标题QGroupBox的title使用粉红色强调 */
    QGroupBox::title {
        subcontrol-origin: margin;
        subcontrol-position: top left;
        left: 10px;
        padding: 0 5px;
        color: #C67A8A;
        font-weight: 600;
    }
    """

class Card(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("card")
        self.setStyleSheet("""
            .card { 
                background-color: #ffffff;
                border-radius: 16px;
                padding: 24px;
                border: 1px solid #f0f0f0;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            }
        """)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

class PresetSettingCard(Card):
    def __init__(self, preset_manager: PresetManager, preset_order_manager: PresetOrderManager, preset_name: str = None, source_page: str = "main", parent=None):
        super().__init__(parent)
        self.preset_manager = preset_manager
        self.preset_order_manager = preset_order_manager  # 添加预设排序管理器
        self.preset_name = preset_name
        self.source_page = source_page  # 记录来源页面
        self.init_ui()
        self.preset_saved = False
        self.save_btn.clicked.connect(self.save_preset)
        self.audio_tags = []  # [(audio_path, emotion_tag, text), ...]
        
        # 🔧 移除固定高度限制，允许内容根据需要扩展
        # 父窗口会通过滚动区域处理内容过长的情况
        
        # 加载所有预设到列表
        self.load_presets_list()
        
        if preset_name:
            self.load_preset(preset_name)
    
    def init_ui(self):
        # 🔧 使用固定的控件尺寸和间距
        base_font_size = 12  # 固定字体大小
        control_height = 32  # 固定控件高度
        spacing = 10  # 固定间距
        
        layout = QVBoxLayout(self)
        layout.setSpacing(spacing)
        layout.setContentsMargins(15, 15, 15, 15)  # 固定边距
        
        # 返回按钮
        nav_layout = QHBoxLayout()
        back_btn = QPushButton("返回")
        back_btn.clicked.connect(self.go_back)
        back_btn.setFixedHeight(control_height)
        back_btn.setFixedWidth(80)  # 固定按钮宽度
        back_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        nav_layout.addWidget(back_btn)
        nav_layout.addStretch()
        
        # 添加现有预设管理区域
        presets_group = QGroupBox("现有预设")
        presets_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {base_font_size + 1}px;
                font-weight: 500;
                padding-top: 15px;
                margin-top: 10px;
            }}
        """)
        presets_layout = QVBoxLayout(presets_group)
        presets_layout.setSpacing(spacing)
        
        # 预设列表和操作按钮
        presets_list_layout = QHBoxLayout()
        presets_list_layout.setSpacing(spacing)
        
        self.presets_list = QComboBox()
        self.presets_list.setFixedHeight(control_height)
        self.presets_list.setMinimumWidth(300)  # 设置最小宽度以完整显示预设名
        self.presets_list.setStyleSheet(f"font-size: {base_font_size}px;")
        # 连接预设选择变化事件
        self.presets_list.currentTextChanged.connect(self.on_preset_selection_changed)
        
        edit_preset_btn = QPushButton("编辑")
        edit_preset_btn.setFixedHeight(control_height)
        edit_preset_btn.setFixedWidth(60)
        edit_preset_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        edit_preset_btn.clicked.connect(self.edit_selected_preset)
        
        delete_preset_btn = QPushButton("删除")
        delete_preset_btn.setFixedHeight(control_height)
        delete_preset_btn.setFixedWidth(60)
        delete_preset_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        delete_preset_btn.clicked.connect(self.delete_selected_preset)
        
        presets_list_layout.addWidget(self.presets_list)
        presets_list_layout.addWidget(edit_preset_btn)
        presets_list_layout.addWidget(delete_preset_btn)
        presets_list_layout.addStretch()  # 添加弹性空间
        
        # 添加男主/女主选择区域
        role_layout = QHBoxLayout()
        role_layout.setSpacing(spacing)
        
        role_label = QLabel("角色标记:")
        role_label.setFixedWidth(80)
        role_label.setStyleSheet(f"font-size: {base_font_size}px;")
        
        self.male_lead_check = QCheckBox("男主")
        self.male_lead_check.setStyleSheet(f"font-size: {base_font_size}px;")
        self.male_lead_check.clicked.connect(self.on_male_lead_changed)
        
        self.female_lead_check = QCheckBox("女主")
        self.female_lead_check.setStyleSheet(f"font-size: {base_font_size}px;")
        self.female_lead_check.clicked.connect(self.on_female_lead_changed)
        
        role_note = QLabel("(下次启动时生效，男主排前，女主排后)")
        role_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.8)}px;")
        
        role_layout.addWidget(role_label)
        role_layout.addWidget(self.male_lead_check)
        role_layout.addWidget(self.female_lead_check)
        role_layout.addWidget(role_note)
        role_layout.addStretch()
        
        presets_layout.addLayout(presets_list_layout)
        presets_layout.addLayout(role_layout)
        
        # 基本信息
        basic_group = QGroupBox("基本信息")
        basic_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {base_font_size + 1}px;
                font-weight: 500;
                padding-top: 15px;
                margin-top: 10px;
            }}
        """)
        basic_info = QVBoxLayout(basic_group)
        basic_info.setSpacing(spacing)
        
        # 预设名称
        name_layout = QHBoxLayout()
        name_layout.setSpacing(spacing)
        
        name_label = QLabel("预设名称")
        name_label.setFixedWidth(80)  # 固定标签宽度以对齐
        name_label.setStyleSheet(f"font-size: {base_font_size}px;")
        
        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText("输入预设名称...")
        self.name_input.setStyleSheet(f"font-size: {base_font_size}px;")
        self.name_input.setFixedHeight(control_height)
        self.name_input.setMinimumWidth(250)  # 设置最小宽度
        
        name_layout.addWidget(name_label)
        name_layout.addWidget(self.name_input)
        name_layout.addStretch()  # 添加弹性空间
        
        # GPT模型路径
        ckpt_layout = QHBoxLayout()
        ckpt_layout.setSpacing(spacing)
        
        ckpt_label = QLabel("GPT模型")
        ckpt_label.setFixedWidth(80)  # 固定标签宽度对齐
        ckpt_label.setStyleSheet(f"font-size: {base_font_size}px;")
        
        self.ckpt_input = QLineEdit()
        self.ckpt_input.setPlaceholderText("选择GPT模型路径...")
        self.ckpt_input.setStyleSheet(f"font-size: {base_font_size}px;")
        self.ckpt_input.setFixedHeight(control_height)
        self.ckpt_input.setMinimumWidth(200)
        
        self.ckpt_btn = QPushButton("选择")
        self.ckpt_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        self.ckpt_btn.setFixedHeight(control_height)
        self.ckpt_btn.setFixedWidth(60)
        self.ckpt_btn.clicked.connect(lambda: self.select_model_path(self.ckpt_input, "ckpt"))
        
        ckpt_layout.addWidget(ckpt_label)
        ckpt_layout.addWidget(self.ckpt_input)
        ckpt_layout.addWidget(self.ckpt_btn)
        ckpt_layout.addStretch()
        
        # SoVITS模型路径
        pth_layout = QHBoxLayout()
        pth_layout.setSpacing(spacing)
        
        pth_label = QLabel("SoVITS模型")
        pth_label.setFixedWidth(80)  # 固定标签宽度对齐
        pth_label.setStyleSheet(f"font-size: {base_font_size}px;")
        
        self.pth_input = QLineEdit()
        self.pth_input.setPlaceholderText("选择SoVITS模型路径...")
        self.pth_input.setStyleSheet(f"font-size: {base_font_size}px;")
        self.pth_input.setFixedHeight(control_height)
        self.pth_input.setMinimumWidth(200)
        
        self.pth_btn = QPushButton("选择")
        self.pth_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        self.pth_btn.setFixedHeight(control_height)
        self.pth_btn.setFixedWidth(60)
        self.pth_btn.clicked.connect(lambda: self.select_model_path(self.pth_input, "pth"))
        
        pth_layout.addWidget(pth_label)
        pth_layout.addWidget(self.pth_input)
        pth_layout.addWidget(self.pth_btn)
        pth_layout.addStretch()
        
        # 参考音频区域
        audio_layout = QVBoxLayout()
        
        # 音频选择和情绪标签行
        audio_header = QHBoxLayout()
        audio_header.setSpacing(spacing)
        
        audio_label = QLabel("参考音频")
        audio_label.setFixedWidth(80)
        audio_label.setStyleSheet(f"font-size: {base_font_size}px;")
        
        self.add_audio_btn = QPushButton("🎵")
        self.add_audio_btn.setFixedWidth(35)
        self.add_audio_btn.setFixedHeight(control_height)
        self.add_audio_btn.clicked.connect(self.add_audio_file)
        
        self.emotion_input = QLineEdit()
        self.emotion_input.setPlaceholderText("情绪标签")
        self.emotion_input.setFixedWidth(120)
        self.emotion_input.setFixedHeight(control_height)
        self.emotion_input.setStyleSheet(f"font-size: {base_font_size}px;")
        
        audio_header.addWidget(audio_label)
        audio_header.addWidget(self.add_audio_btn)
        audio_header.addWidget(self.emotion_input)
        audio_header.addStretch()
        
        # 音频文本输入行
        audio_text_layout = QHBoxLayout()
        audio_text_layout.setSpacing(spacing)
        
        audio_text_label = QLabel("音频文本")
        audio_text_label.setFixedWidth(80)
        audio_text_label.setStyleSheet(f"font-size: {base_font_size}px;")
        
        self.audio_text_input = QLineEdit()
        self.audio_text_input.setPlaceholderText("输入参考音频对应的文本内容")
        self.audio_text_input.setFixedHeight(control_height)
        self.audio_text_input.setMinimumWidth(200)
        self.audio_text_input.setStyleSheet(f"font-size: {base_font_size}px;")
        self.audio_text_input.returnPressed.connect(self.add_audio_tag)
        
        add_tag_btn = QPushButton("添加")
        add_tag_btn.setFixedHeight(control_height)
        add_tag_btn.setFixedWidth(60)
        add_tag_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        add_tag_btn.clicked.connect(self.add_audio_tag)
        
        audio_text_layout.addWidget(audio_text_label)
        audio_text_layout.addWidget(self.audio_text_input)
        audio_text_layout.addWidget(add_tag_btn)
        audio_text_layout.addStretch()
        
        # 音频列表行
        audio_list_layout = QHBoxLayout()
        audio_list_layout.setSpacing(spacing)
        
        list_label = QLabel("音频列表")
        list_label.setFixedWidth(80)
        list_label.setStyleSheet(f"font-size: {base_font_size}px;")
        
        self.audio_list = QComboBox()
        self.audio_list.setPlaceholderText("已添加的参考音频...")
        self.audio_list.setMinimumWidth(200)
        self.audio_list.setFixedHeight(control_height)
        self.audio_list.setStyleSheet(f"font-size: {base_font_size}px;")
        
        delete_btn = QPushButton("删除")
        delete_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        delete_btn.setFixedHeight(control_height)
        delete_btn.setFixedWidth(60)
        delete_btn.clicked.connect(self.delete_selected_audio)
        
        audio_list_layout.addWidget(list_label)
        audio_list_layout.addWidget(self.audio_list)
        audio_list_layout.addWidget(delete_btn)
        audio_list_layout.addStretch()
        
        audio_layout.addLayout(audio_header)
        audio_layout.addLayout(audio_text_layout)
        audio_layout.addLayout(audio_list_layout)
        
        # 添加所有基本信息组件
        basic_info.addLayout(name_layout)
        basic_info.addLayout(ckpt_layout)
        basic_info.addLayout(pth_layout)
        basic_info.addLayout(audio_layout)
        
        # 节奏设置
        rhythm_group = QGroupBox("节奏设置")
        rhythm_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {base_font_size + 1}px;
                font-weight: 500;
                padding-top: 15px;
                margin-top: 10px;
            }}
        """)
        rhythm_layout = QGridLayout()
        rhythm_layout.setSpacing(spacing)
        rhythm_layout.setContentsMargins(15, 15, 15, 15)
        
        # 语速设置
        speed_factor_label = QLabel("语速")
        speed_factor_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.speed_factor_spin = QDoubleSpinBox()
        self.speed_factor_spin.setRange(0.5, 2.0)
        self.speed_factor_spin.setSingleStep(0.1)
        self.speed_factor_spin.setValue(1.0)
        self.speed_factor_spin.setMinimumHeight(control_height)
        self.speed_factor_spin.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        speed_factor_note = QLabel("调节语音生成的速度，1.0为正常语速")
        speed_factor_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        rhythm_layout.addWidget(speed_factor_label, 0, 0)
        rhythm_layout.addWidget(self.speed_factor_spin, 0, 1)
        rhythm_layout.addWidget(speed_factor_note, 0, 2)
        
        # 文本切分设置
        split_label = QLabel("文本切分")
        split_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.split_combo = QComboBox()
        self.split_combo.setMaximumWidth(200)
        self.split_combo.setMinimumHeight(control_height)
        self.split_combo.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        split_options = [
            "cut0（不切分，适合短句）",
            "cut1（每4句一切，适合对话）",
            "cut2（每50字一切，适合长句）",
            "cut3（按中文句号。切分，适合正常朗读）",
            "cut4（按英文句号.切分，适合英文）",
            "cut5（按标点符号切分，推荐）"
        ]
        self.split_combo.addItems(split_options)
        self.split_combo.setCurrentIndex(1)  # 🔧 默认选择 cut1（每4句一切，适合对话）
        split_note = QLabel("选择合适的切分方式可以让朗读更自然，显存不够时请选择更小的切分长度")
        split_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        rhythm_layout.addWidget(split_label, 1, 0)
        rhythm_layout.addWidget(self.split_combo, 1, 1)
        rhythm_layout.addWidget(split_note, 1, 2)
        
        # 段间隔设置
        interval_label = QLabel("分段间隔")
        interval_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.interval_spin = QDoubleSpinBox()
        self.interval_spin.setRange(0.01, 1.0)
        self.interval_spin.setSingleStep(0.01)
        self.interval_spin.setValue(0.3)
        self.interval_spin.setMaximumWidth(80)
        self.interval_spin.setMinimumHeight(control_height)
        self.interval_spin.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        interval_note = QLabel("分段合成时的间隔时长（秒），推荐0.3秒，最小0.01秒")
        interval_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        rhythm_layout.addWidget(interval_label, 2, 0)
        rhythm_layout.addWidget(self.interval_spin, 2, 1)
        rhythm_layout.addWidget(interval_note, 2, 2)
        
        rhythm_group.setLayout(rhythm_layout)
        
        # 推理设置
        infer_group = QGroupBox("推理设置")
        infer_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(self.window().height() * 0.02)}px;
                margin-top: {int(self.window().height() * 0.014)}px;
            }}
        """)
        infer_layout = QGridLayout()
        infer_layout.setSpacing(int(self.window().width() * 0.015))
        infer_layout.setVerticalSpacing(int(self.window().height() * 0.02))
        
        # 温度参数
        temp_label = QLabel("温度")
        temp_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.temp_spin = QDoubleSpinBox()
        self.temp_spin.setRange(0.1, 2.0)
        self.temp_spin.setValue(0.6)  # 🔧 更新默认值为0.6
        self.temp_spin.setSingleStep(0.1)
        self.temp_spin.setDecimals(1)
        self.temp_spin.setMinimumHeight(control_height)
        
        # Top-K参数
        topk_label = QLabel("Top-K")
        topk_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.topk_spin = QSpinBox()
        self.topk_spin.setRange(1, 100)
        self.topk_spin.setValue(15)  # v4版本推荐值
        self.topk_spin.setSingleStep(1)
        self.topk_spin.setMinimumHeight(control_height)
        
        # Top-P参数
        topp_label = QLabel("Top-P")
        topp_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.topp_spin = QDoubleSpinBox()
        self.topp_spin.setRange(0.1, 1.0)
        self.topp_spin.setValue(1.0)  # v4版本推荐值
        self.topp_spin.setSingleStep(0.1)
        self.topp_spin.setDecimals(1)
        self.topp_spin.setMinimumHeight(control_height)
        
        # 重复惩罚参数
        penalty_label = QLabel("重复惩罚")
        penalty_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.penalty_spin = QDoubleSpinBox()
        self.penalty_spin.setRange(1.0, 3.0)
        self.penalty_spin.setValue(1.35)  # v4版本推荐值
        self.penalty_spin.setSingleStep(0.01)
        self.penalty_spin.setDecimals(2)
        self.penalty_spin.setMinimumHeight(control_height)
        
        # 文本语言设置
        lang_label = QLabel("文本语言")
        lang_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.lang_combo = QComboBox()
        self.lang_combo.addItems(["all_zh", "zh", "en", "ja", "auto"])
        self.lang_combo.setCurrentText("all_zh")  # 默认为all_zh
        self.lang_combo.setMinimumHeight(control_height)
        
        # 批处理设置
        batch_label = QLabel("批处理")
        batch_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        batch_layout = QHBoxLayout()
        
        self.batch_size_spin = QSpinBox()
        self.batch_size_spin.setRange(1, 5)
        self.batch_size_spin.setValue(1)  # 默认为1
        self.batch_size_spin.setMinimumHeight(control_height)
        
        self.parallel_infer_check = QCheckBox("并行推理")
        self.parallel_infer_check.setChecked(True)  # 🔧 更新默认值为True
        
        self.split_bucket_check = QCheckBox("分桶处理")
        self.split_bucket_check.setChecked(False)  # 默认禁用
        
        batch_layout.addWidget(self.batch_size_spin)
        batch_layout.addWidget(self.parallel_infer_check)
        batch_layout.addWidget(self.split_bucket_check)
        
        # v4版本特有参数
        # 采样步数设置
        sample_steps_label = QLabel("采样步数")
        sample_steps_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.sample_steps_spin = QSpinBox()
        self.sample_steps_spin.setRange(4, 128)
        self.sample_steps_spin.setValue(8)  # v4默认值调整为8
        self.sample_steps_spin.setSingleStep(4)
        self.sample_steps_spin.setMinimumHeight(control_height)
        sample_steps_note = QLabel("控制采样质量和速度，值越大质量越好但速度越慢")
        sample_steps_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        
        # 音频超分辨率设置
        if_sr_label = QLabel("音频超分辨率")
        if_sr_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.if_sr_check = QCheckBox("启用超分辨率")
        self.if_sr_check.setChecked(True)  # 🔧 更新默认值为True
        self.if_sr_check.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        if_sr_note = QLabel("提高音频质量，但会增加计算时间")
        if_sr_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        
        # 辅助参考音频设置（v4特有）
        aux_ref_label = QLabel("辅助参考音频")
        aux_ref_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.aux_ref_check = QCheckBox("启用多音色融合")
        self.aux_ref_check.setChecked(False)  # 默认关闭
        self.aux_ref_check.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        aux_ref_note = QLabel("可以添加多个辅助参考音频进行音色融合（建议同性别）")
        aux_ref_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        
        # 添加到布局
        infer_layout.addWidget(temp_label, 0, 0)
        infer_layout.addWidget(self.temp_spin, 0, 1)
        infer_layout.addWidget(topk_label, 0, 2)
        infer_layout.addWidget(self.topk_spin, 0, 3)
        infer_layout.addWidget(topp_label, 1, 0)
        infer_layout.addWidget(self.topp_spin, 1, 1)
        infer_layout.addWidget(penalty_label, 1, 2)
        infer_layout.addWidget(self.penalty_spin, 1, 3)
        infer_layout.addWidget(lang_label, 2, 0)
        infer_layout.addWidget(self.lang_combo, 2, 1)
        infer_layout.addWidget(batch_label, 2, 2)
        infer_layout.addLayout(batch_layout, 2, 3)
        
        # v4特有参数
        infer_layout.addWidget(sample_steps_label, 3, 0)
        infer_layout.addWidget(self.sample_steps_spin, 3, 1)
        infer_layout.addWidget(sample_steps_note, 3, 2, 1, 2)
        infer_layout.addWidget(if_sr_label, 4, 0)
        infer_layout.addWidget(self.if_sr_check, 4, 1)
        infer_layout.addWidget(if_sr_note, 4, 2, 1, 2)
        infer_layout.addWidget(aux_ref_label, 5, 0)
        infer_layout.addWidget(self.aux_ref_check, 5, 1)
        infer_layout.addWidget(aux_ref_note, 5, 2, 1, 2)
        
        infer_group.setLayout(infer_layout)
        
        # 按钮区域
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        # 恢复默认值按钮
        self.reset_defaults_btn = QPushButton("恢复默认值")
        self.reset_defaults_btn.setFixedHeight(40)
        self.reset_defaults_btn.setFixedWidth(120)
        self.reset_defaults_btn.setStyleSheet(f"font-size: {base_font_size}px; background-color: #f0f0f0; color: #333;")
        self.reset_defaults_btn.clicked.connect(self.reset_to_defaults)
        
        # 保存按钮
        self.save_btn = QPushButton("保存预设")
        self.save_btn.setObjectName("generate_btn")
        self.save_btn.setFixedHeight(40)  # 固定保存按钮高度
        self.save_btn.setFixedWidth(120)  # 固定保存按钮宽度
        self.save_btn.setStyleSheet(f"font-size: {base_font_size}px;")
        
        button_layout.addWidget(self.reset_defaults_btn)
        button_layout.addWidget(self.save_btn)
        
        # 添加所有组件到主布局
        layout.addLayout(nav_layout)
        layout.addWidget(presets_group)
        layout.addWidget(basic_group)
        layout.addWidget(rhythm_group)
        layout.addWidget(infer_group)
        layout.addLayout(button_layout)
    
    # 🔧 移除resize事件处理，因为现在使用固定控件大小
    pass
    
    def select_model_path(self, input_widget: QLineEdit, model_type: str):
        """选择模型文件"""
        file_filter = "GPT模型 (*.ckpt)" if model_type == "ckpt" else "SoVITS模型 (*.pth)"
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            f"选择{model_type}模型文件",
            "",
            file_filter
        )
        if file_name:
            input_widget.setText(file_name)
    
    def add_audio_file(self):
        """选择音频文件"""
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "选择音频文件",
            "",
            "音频文件 (*.wav *.mp3)"
        )
        if file_name:
            self.current_audio = file_name
            self.add_audio_btn.setText("✓")
            self.add_audio_btn.setStyleSheet("color: #C67A8A;")
            self.add_audio_btn.setToolTip(file_name)
            # 引导用户填写后续信息
            self.emotion_input.setFocus()
            # 在状态栏提示用户填写完整信息
            QMessageBox.information(self, "提示", "请填写情绪标签和音频文本内容，然后点击'添加'按钮")
            
            # 尝试自动填充音频文本框
            try:
                # 从音频文件名中提取文本作为参考
                base_name = os.path.splitext(os.path.basename(file_name))[0]
                # 如果文本框为空，才填充参考文本
                if not self.audio_text_input.text():
                    self.audio_text_input.setText(base_name)
                    self.audio_text_input.selectAll()  # 选中文本以便用户直接替换
            except:
                pass
    
    def add_audio_tag(self):
        """添加音频和情绪标签对"""
        tag = self.emotion_input.text().strip()
        text = self.audio_text_input.text().strip()
        
        if hasattr(self, 'current_audio') and tag and text:
            # 使用用户手动输入的文本内容
            display_name = f"{os.path.basename(self.current_audio)} - {tag} - {text}"
            self.audio_tags.append((self.current_audio, tag, text))
            self.audio_list.addItem(display_name)
            
            # 添加调试输出
            
            # 清空输入框
            self.emotion_input.clear()
            self.audio_text_input.clear()
            self.add_audio_btn.setText("🎵")
            self.add_audio_btn.setStyleSheet("")
            delattr(self, 'current_audio')
        else:
            # 提示用户填写完整信息
            if not hasattr(self, 'current_audio'):
                QMessageBox.warning(self, "提示", "请先选择音频文件")
            elif not tag:
                QMessageBox.warning(self, "提示", "请输入情绪/场景标签")
            elif not text:
                QMessageBox.warning(self, "提示", "请输入音频文本内容")
    
    def delete_selected_audio(self):
        """删除选中的音频"""
        current_index = self.audio_list.currentIndex()
        if current_index >= 0:
            self.audio_list.removeItem(current_index)
            self.audio_tags.pop(current_index)
    
    def load_preset(self, preset_name: str):
        """加载预设数据"""
        preset_info = self.preset_manager.get_preset(preset_name)
        if not preset_info:
            return
            
        settings, audio_files = preset_info
        
        
        # 填充基本信息
        self.name_input.setText(preset_name)
        # 优先使用model_path，如果没有则使用gpt_path
        gpt_path = settings.get('model_path', '') or settings.get('gpt_path', '')
        self.ckpt_input.setText(gpt_path)
        self.pth_input.setText(settings.get('sovits_path', ''))
        
        # 清空现有音频列表
        self.audio_list.clear()
        self.audio_tags.clear()
        
        # 填充音频列表
     
        for path, emotion, text in audio_files:
            
            
            display_name = f"{os.path.basename(path)} - {emotion} - {text}"
            self.audio_tags.append((path, emotion, text))
            self.audio_list.addItem(display_name)
        
        # 填充节奏设置 - 🔧 更新文本切分默认值
        split_method = settings.get('text_split_method', 'cut1')  # 更新默认值为cut1
        index = self.split_combo.findText(split_method, Qt.MatchFlag.MatchStartsWith)
        if index >= 0:
            self.split_combo.setCurrentIndex(index)
        self.interval_spin.setValue(settings.get('fragment_interval', 0.3))
        self.speed_factor_spin.setValue(settings.get('speed_factor', 1.0))  # 加载语速设置
        
        # 填充推理设置 - 🔧 更新默认值
        self.temp_spin.setValue(settings.get('temperature', 0.6))  # 更新默认值为0.6
        self.topk_spin.setValue(settings.get('top_k', 15))  # 更新默认值为15
        self.topp_spin.setValue(settings.get('top_p', 1.0))
        self.penalty_spin.setValue(settings.get('repetition_penalty', 1.35))  # 更新默认值为1.35
        
        # 批处理设置 - 🔧 更新默认值
        self.batch_size_spin.setValue(settings.get('batch_size', 1))
        self.parallel_infer_check.setChecked(settings.get('parallel_infer', True))  # 更新默认值为True
        self.split_bucket_check.setChecked(settings.get('split_bucket', False))
        
        # v4版本特有参数 - 🔧 更新默认值
        self.sample_steps_spin.setValue(settings.get('sample_steps', 8))  # 更新默认值为8
        self.if_sr_check.setChecked(settings.get('if_sr', True))  # 更新默认值为True
        self.aux_ref_check.setChecked(settings.get('aux_ref_enabled', False))
        
        # 设置语言选项
        text_lang = settings.get('text_lang', 'all_zh')
        index = self.lang_combo.findText(text_lang)
        if index >= 0:
            self.lang_combo.setCurrentIndex(index)
        

    
    def save_preset(self):
        """保存预设"""
        name = self.name_input.text().strip()
        if not name:
            QMessageBox.warning(self, "提示", "请输入预设名称")
            return
            
        if not self.audio_tags:
            QMessageBox.warning(self, "提示", "请添加至少一个参考音频")
            return
        
        # 获取第一个音频的路径、情绪和文本
        first_audio_path, first_emotion, first_text = self.audio_tags[0]
        
        # 添加调试输出
        
        settings = {
            'model_path': self.ckpt_input.text().strip(),
            'gpt_path': self.ckpt_input.text().strip(),  # 确保与gpt_sovits.py兼容
            'sovits_path': self.pth_input.text().strip(),
            'ref_audio': first_audio_path,  # 参考音频路径（字符串）
            'ref_audio_list': [path for path, _, _ in self.audio_tags],  # 参考音频路径列表
            'text_split_method': self.split_combo.currentText().split('（')[0],  # 文本切分方法
            'fragment_interval': self.interval_spin.value(),  # 分段间隔
            'temperature': self.temp_spin.value(),  # 温度参数
            'top_k': int(self.topk_spin.value()),  # Top-K参数
            'top_p': self.topp_spin.value(),  # Top-P参数
            'repetition_penalty': self.penalty_spin.value(),  # 重复惩罚参数
            'speed_factor': self.speed_factor_spin.value(),  # 语速参数
            
            # 添加参考音频的文本和情绪信息 - 完全不修改，保留原始文本
            'ref_text': first_text,  # 使用用户输入的音频文本，原样保存
            'ref_emotion': first_emotion,  # 使用用户输入的情绪标签
            'ref_language': self.lang_combo.currentText(),  # 参考语言
            
            # 添加更多高级参数，从界面元素读取
            'batch_size': self.batch_size_spin.value(),
            'batch_threshold': 0.75,  # 固定值
            'parallel_infer': self.parallel_infer_check.isChecked(),
            'pitch': 1.0,  # 固定值
            'role': '',
            'seed': -1,  # 固定值
            'split_bucket': self.split_bucket_check.isChecked(),
            'text_lang': self.lang_combo.currentText(),
            'text_language': self.lang_combo.currentText(),  # 确保与gpt_sovits.py兼容
            
            # v4版本特有参数
            'sample_steps': self.sample_steps_spin.value(),  # 采样步数
            'if_sr': self.if_sr_check.isChecked(),  # 音频超分辨率
            'aux_ref_enabled': self.aux_ref_check.isChecked(),  # 启用辅助参考音频
        }
        
        # 打印settings字典中的关键参数
        
        # 如果有多个音频，我们需要保存每个音频的信息
        if len(self.audio_tags) > 1:
            settings['all_audio_info'] = [
                {'path': path, 'emotion': emotion, 'text': text} 
                for path, emotion, text in self.audio_tags
            ]
        
        # 转换音频标签格式
        audio_files = [(path, emotion, text) for path, emotion, text in self.audio_tags]
        
        if self.preset_manager.add_preset(name, settings, audio_files):
            self.preset_saved = True
            QMessageBox.information(self, "成功", f"预设保存成功\n参考音频文本: {first_text}\n参考音频情绪: {first_emotion}")
            
            # 通知MainWindow更新预设列表
            parent = self.window()
            if isinstance(parent, MainWindow):
                parent.load_presets()
                
                # 根据来源页面返回并更新配置
                if self.source_page == "first_segment":
                    # 获取当前的 FirstSegmentCard
                    for i in range(parent.stack.count()):
                        widget = parent.stack.widget(i)
                        if isinstance(widget, QWidget) and widget.findChild(FirstSegmentCard):
                            first_segment_card = widget.findChild(FirstSegmentCard)
                            if first_segment_card:
                                # 更新预设选择并加载配置
                                first_segment_card.preset_combo.setCurrentText(name)
                                first_segment_card.current_preset_settings = settings
                            break
                    parent.stack.setCurrentWidget(widget)
                else:
                    parent.show_main_page()
        else:
            QMessageBox.warning(self, "错误", "预设保存失败")
    
    def go_back(self):
        """返回上一页面"""
        if not self.preset_saved:
            reply = QMessageBox.question(
                self, 
                "提示", 
                "预设尚未保存，确定要返回吗？",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return
                
        parent = self.window()
        if isinstance(parent, MainWindow):
            if self.source_page == "first_segment":
                # 获取当前的 FirstSegmentCard
                for i in range(parent.stack.count()):
                    widget = parent.stack.widget(i)
                    if isinstance(widget, QWidget) and widget.findChild(FirstSegmentCard):
                        parent.stack.setCurrentWidget(widget)
                        break
            elif self.source_page == "segment":
                # 返回段落处理页面
                parent.show_main_page()  # 这将通过source_page="segment"逻辑返回到段落处理页面
            else:
                parent.show_main_page()

    def load_presets_list(self):
        """加载所有预设到列表"""
        self.presets_list.clear()
        all_presets = [preset[0] for preset in self.preset_manager.get_all_presets()]
        
        # 🔧 使用预设排序管理器进行排序
        sorted_presets = self.preset_order_manager.sort_presets(all_presets)
        self.presets_list.addItems(sorted_presets)
        
        # 清理已删除的预设
        self.preset_order_manager.cleanup_deleted_presets(all_presets)
    
    def on_preset_selection_changed(self, preset_name: str):
        """当预设选择改变时更新男主/女主勾选状态"""
        if not preset_name:
            return
            
        # 更新勾选框状态，但不触发信号
        self.male_lead_check.blockSignals(True)
        self.female_lead_check.blockSignals(True)
        
        self.male_lead_check.setChecked(self.preset_order_manager.is_male_lead(preset_name))
        self.female_lead_check.setChecked(self.preset_order_manager.is_female_lead(preset_name))
        
        self.male_lead_check.blockSignals(False)
        self.female_lead_check.blockSignals(False)
    
    def on_male_lead_changed(self, checked: bool):
        """处理男主勾选状态改变"""
        preset_name = self.presets_list.currentText()
        if not preset_name:
            return
            
        if checked:
            self.preset_order_manager.set_male_lead(preset_name)
            # 取消女主勾选（互斥）
            self.female_lead_check.blockSignals(True)
            self.female_lead_check.setChecked(False)
            self.female_lead_check.blockSignals(False)
        else:
            self.preset_order_manager.remove_lead_status(preset_name)
    
    def on_female_lead_changed(self, checked: bool):
        """处理女主勾选状态改变"""
        preset_name = self.presets_list.currentText()
        if not preset_name:
            return
            
        if checked:
            self.preset_order_manager.set_female_lead(preset_name)
            # 取消男主勾选（互斥）
            self.male_lead_check.blockSignals(True)
            self.male_lead_check.setChecked(False)
            self.male_lead_check.blockSignals(False)
        else:
            self.preset_order_manager.remove_lead_status(preset_name)
    
    def edit_selected_preset(self):
        """编辑选中的预设"""
        preset_name = self.presets_list.currentText()
        if not preset_name:
            QMessageBox.warning(self, "提示", "请选择要编辑的预设")
            return
        
        # 清除当前表单
        self.name_input.clear()
        self.ckpt_input.clear()
        self.pth_input.clear()
        self.audio_list.clear()
        self.audio_tags.clear()
        
        # 加载选中的预设
        self.load_preset(preset_name)
    
    def delete_selected_preset(self):
        """删除选中的预设"""
        preset_name = self.presets_list.currentText()
        if not preset_name:
            QMessageBox.warning(self, "提示", "请选择要删除的预设")
            return
        
        reply = QMessageBox.question(
            self, 
            "确认删除", 
            f"确定要删除预设 '{preset_name}' 吗？此操作不可撤销。",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            if self.preset_manager.delete_preset(preset_name):
                QMessageBox.information(self, "成功", f"预设 '{preset_name}' 已删除")
                # 重新加载预设列表
                self.load_presets_list()
                
                # 清除表单
                self.name_input.clear()
                self.ckpt_input.clear()
                self.pth_input.clear()
                self.audio_list.clear()
                self.audio_tags.clear()
                
                # 通知MainWindow更新预设列表
                parent = self.window()
                if isinstance(parent, MainWindow):
                    parent.load_presets()
            else:
                QMessageBox.warning(self, "错误", f"删除预设 '{preset_name}' 失败")
    
    def reset_to_defaults(self):
        """恢复所有参数为默认值"""
        # 📋 默认参数配置
        # 文本切分=cut1，分段间隔=0.3，温度=0.6，Top-K=15，Top-P=1.0，
        # 重复惩罚=1.35，并行处理=True，采样=8，音频超分辨率=True
        
        # 🔧 直接应用默认值，无需确认对话框
        # 恢复所有参数为默认值
        self.split_combo.setCurrentIndex(1)  # cut1
        self.interval_spin.setValue(0.3)  # 分段间隔
        self.temp_spin.setValue(0.6)  # 温度
        self.topk_spin.setValue(15)  # Top-K
        self.topp_spin.setValue(1.0)  # Top-P
        self.penalty_spin.setValue(1.35)  # 重复惩罚
        self.parallel_infer_check.setChecked(True)  # 并行处理
        self.sample_steps_spin.setValue(8)  # 采样步数
        self.if_sr_check.setChecked(True)  # 音频超分辨率
        
        # 其他参数也恢复为合理默认值
        self.speed_factor_spin.setValue(1.0)  # 语速
        self.lang_combo.setCurrentText("all_zh")  # 文本语言
        self.batch_size_spin.setValue(1)  # 批处理大小
        self.split_bucket_check.setChecked(False)  # 分桶处理
        self.aux_ref_check.setChecked(False)  # 辅助参考音频
        
        # 🔧 完全静默执行，无任何提示

class FirstSegmentCard(Card):
    def __init__(self, segments: List[str], preset_manager: PresetManager, preset_order_manager: PresetOrderManager = None, parent=None):
        super().__init__(parent)
        self.segments = segments
        self.preset_manager = preset_manager
        self.preset_order_manager = preset_order_manager
        self.current_segment_index = 0
        self.is_generating_preview = False
        self.preview_generated = False
        self.gpt_sovits = GPTSoVITS()
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)
        self.current_preset_settings = None  # 添加当前预设设置的存储
        self.processed_segments = self.segments.copy()  # 存储处理后的文本
        
        # 设置初始音量并监听音频设备变化
        self.current_volume = 70
        self.audio_output.setVolume(self.current_volume / 100.0)
        
        # 创建音频设备变化的定时检测器
        self.volume_check_timer = QTimer(self)
        self.volume_check_timer.timeout.connect(self.check_system_volume)
        self.volume_check_timer.start(1000)  # 每秒检查一次系统音量变化
        
        # 添加搜索相关变量
        self.search_mode = False
        self.search_results = []
        self.search_index = 0
        self.last_search_query = ""
        
        self.init_ui()
        
        # 连接播放器信号
        self.player.positionChanged.connect(self.update_position)
        self.player.durationChanged.connect(self.update_duration)
        self.preview_progress.sliderMoved.connect(self.set_position)
    
    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(20)
        
        # 顶部导航
        nav_layout = QHBoxLayout()
        back_btn = QPushButton("返回")
        back_btn.clicked.connect(self.go_back)
        nav_layout.addWidget(back_btn)
        
        # 添加搜索功能
        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("搜索文本内容")
        self.search_edit.textChanged.connect(self.on_search_text_changed)
        self.search_btn = QPushButton("搜索")
        self.search_btn.clicked.connect(self.search_text)
        self.confirm_search_btn = QPushButton("退出搜索")
        self.confirm_search_btn.clicked.connect(self.confirm_search)
        self.confirm_search_btn.setEnabled(False)
        
        search_layout.addWidget(self.search_edit)
        search_layout.addWidget(self.search_btn)
        search_layout.addWidget(self.confirm_search_btn)
        
        nav_layout.addLayout(search_layout)
        
        # 添加页码显示
        self.page_label = QLabel(f"当前第 {self.current_segment_index + 1}/{len(self.segments)} 段")
        nav_layout.addWidget(self.page_label, alignment=Qt.AlignmentFlag.AlignCenter)
        
        # 添加翻页按钮
        nav_btn_layout = QHBoxLayout()
        self.prev_btn = QPushButton("上一段")
        self.prev_btn.clicked.connect(self.prev_segment)
        self.prev_btn.setEnabled(False)  # 初始时不能往前翻
        
        self.next_btn = QPushButton("下一段")
        self.next_btn.clicked.connect(self.next_segment)
        self.next_btn.setEnabled(len(self.segments) > 1)  # 有多段时才能向后翻
        
        nav_btn_layout.addWidget(self.prev_btn)
        nav_btn_layout.addWidget(self.next_btn)
        nav_layout.addLayout(nav_btn_layout)
        
        # 预设选择区域
        preset_group = QGroupBox("预设选择")
        preset_layout = QHBoxLayout(preset_group)
        
        self.preset_combo = QComboBox()
        self.preset_combo.currentIndexChanged.connect(self.on_preset_changed)
        self.load_presets()  # 加载所有预设
        
        self.new_preset_btn = QPushButton("新建预设")
        self.new_preset_btn.clicked.connect(self.create_new_preset)
        
        self.edit_preset_btn = QPushButton("调整预设")
        self.edit_preset_btn.clicked.connect(self.edit_current_preset)
        
        preset_layout.addWidget(self.preset_combo)
        preset_layout.addWidget(self.new_preset_btn)
        preset_layout.addWidget(self.edit_preset_btn)
        
        # 文本编辑区域
        text_group = QGroupBox("当前文本")
        text_layout = QVBoxLayout(text_group)
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(False)  # 允许编辑
        self.text_edit.setMinimumHeight(150)
        text_layout.addWidget(self.text_edit)
        
        # 文本操作按钮区域
        text_btn_layout = QHBoxLayout()
        
        # 保存按钮
        self.save_btn = QPushButton("保存")
        self.save_btn.clicked.connect(self.save_text)
        text_btn_layout.addWidget(self.save_btn)
        
        # 复制按钮
        self.copy_btn = QPushButton("复制")
        self.copy_btn.clicked.connect(self.copy_text)
        text_btn_layout.addWidget(self.copy_btn)
        
        # 替换区域
        self.find_edit = QLineEdit()
        self.find_edit.setPlaceholderText("查找文本")
        self.replace_edit = QLineEdit()
        self.replace_edit.setPlaceholderText("替换为")
        self.replace_btn = QPushButton("替换")
        self.replace_btn.clicked.connect(self.replace_text)
        
        text_btn_layout.addWidget(self.find_edit)
        text_btn_layout.addWidget(self.replace_edit)
        text_btn_layout.addWidget(self.replace_btn)
        
        text_layout.addLayout(text_btn_layout)
        
        # 试听区域
        preview_group = QGroupBox("试听")
        preview_layout = QVBoxLayout(preview_group)
        
        # 试听按钮和状态
        preview_btn_layout = QHBoxLayout()
        self.preview_btn = QPushButton("生成试听")
        self.preview_btn.clicked.connect(self.generate_preview)
        self.preview_status = QLabel("🔄 未生成")  # 默认状态
        preview_btn_layout.addWidget(self.preview_btn)
        preview_btn_layout.addWidget(self.preview_status)
        preview_btn_layout.addStretch()
        
        # 试听控制
        preview_control_layout = QHBoxLayout()
        self.play_btn = QPushButton("▶️")
        self.play_btn.setEnabled(False)
        self.play_btn.clicked.connect(self.play_preview)
        self.preview_progress = QSlider(Qt.Orientation.Horizontal)
        self.preview_progress.setEnabled(False)
        self.preview_progress.sliderMoved.connect(self.set_position)
        
        # 添加音量控制
        volume_layout = QHBoxLayout()
        volume_icon = QLabel("🔊")
        self.volume_slider = QSlider(Qt.Orientation.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(70)  # 默认音量70%
        self.volume_slider.valueChanged.connect(self.set_volume)
        volume_layout.addWidget(volume_icon)
        volume_layout.addWidget(self.volume_slider)
        
        preview_control_layout.addWidget(self.play_btn)
        preview_control_layout.addWidget(self.preview_progress)
        
        preview_layout.addLayout(preview_btn_layout)
        preview_layout.addLayout(preview_control_layout)
        preview_layout.addLayout(volume_layout)  # 添加音量控制
        
        # 生成全书按钮
        self.generate_all_btn = QPushButton("生成全书")
        self.generate_all_btn.setObjectName("generate_btn")
        self.generate_all_btn.clicked.connect(self.generate_all)
        
        # 添加所有组件到主布局
        layout.addLayout(nav_layout)
        layout.addWidget(preset_group)
        layout.addWidget(text_group)
        layout.addWidget(preview_group)
        layout.addWidget(self.generate_all_btn, alignment=Qt.AlignmentFlag.AlignCenter)
        
        # 显示第一段文本
        self.update_text_display()
    
    def load_presets(self):
        """加载所有预设"""
        self.preset_combo.clear()
        presets = self.preset_manager.get_all_presets()
        preset_names = [name for name, _, _ in presets]
        
        # 🔧 使用预设排序管理器进行排序
        if self.preset_order_manager:
            sorted_names = self.preset_order_manager.sort_presets(preset_names)
            for name in sorted_names:
                self.preset_combo.addItem(name)
        else:
            # 后备方案：按原来的方式添加
            for name in preset_names:
                self.preset_combo.addItem(name)
                
        self.preset_combo.addItem("新建预设...")
    
    def set_volume(self, volume):
        """设置音量大小"""
        # 获取系统音量设置，确保与系统音量同步
        system_volume = QMediaDevices.defaultAudioOutput().volume() * 100
        # 使用滑块设置的音量或系统音量（当滑块被用户移动时）
        if volume != self.current_volume:  # 用户手动调整了滑块
            # 将滑块的0-100值转换为QMediaPlayer的0.0-1.0音量值
            volume_value = volume / 100.0
            self.audio_output.setVolume(volume_value)
            # 保存音量设置，以便在切换段落或重新试听时保持一致
            self.current_volume = volume
        else:  # 系统音量改变
            # 更新滑块显示
            self.volume_slider.setValue(int(system_volume))
            # 更新音频输出音量
            self.audio_output.setVolume(system_volume / 100.0)
            # 保存当前音量设置
            self.current_volume = int(system_volume)
    
    def on_preset_changed(self, index):
        """预设选择改变时的处理"""
        preset_name = self.preset_combo.currentText()
        if preset_name == "新建预设...":
            self.create_new_preset()
            return
            
        # 加载预设数据
        preset_info = self.preset_manager.get_preset(preset_name)
        if preset_info:
            settings, audio_files = preset_info
            # 确保设置包含gpt_sovits.py所需的所有必要字段
            if 'gpt_path' not in settings and 'model_path' in settings:
                settings['gpt_path'] = settings['model_path']
            if 'ref_language' not in settings:
                settings['ref_language'] = settings.get('text_lang', 'all_zh')
            self.current_preset_settings = settings  # 保存当前预设设置
    
    def create_new_preset(self):
        """创建新预设"""
        parent = self.window()
        if isinstance(parent, MainWindow):
            parent.show_preset_setting(source_page="first_segment")
    
    def edit_current_preset(self):
        """编辑当前预设"""
        preset_name = self.preset_combo.currentText()
        if preset_name and preset_name != "新建预设...":
            parent = self.window()
            if isinstance(parent, MainWindow):
                parent.show_preset_setting(preset_name, source_page="first_segment")
    
    def go_back(self):
        """返回主页面"""
        parent = self.window()
        if isinstance(parent, MainWindow):
            parent.show_main_page()
    
    def update_text_display(self):
        """更新文本显示"""
        self.text_edit.setText(self.processed_segments[self.current_segment_index])
        
        # 更新页码显示
        if self.search_mode:
            current_search_index = self.search_results.index(self.current_segment_index) + 1
            self.page_label.setText(f"搜索结果: {current_search_index}/{len(self.search_results)} (第 {self.current_segment_index + 1}/{len(self.segments)} 段)")
        else:
            self.page_label.setText(f"当前第 {self.current_segment_index + 1}/{len(self.segments)} 段")
        
        # 更新翻页按钮状态
        if self.search_mode:
            current_result_index = self.search_results.index(self.current_segment_index)
            self.prev_btn.setEnabled(current_result_index > 0)
            self.next_btn.setEnabled(current_result_index < len(self.search_results) - 1)
        else:
            self.prev_btn.setEnabled(self.current_segment_index > 0)
            self.next_btn.setEnabled(self.current_segment_index < len(self.segments) - 1)
        
        # 如果在搜索模式下，高亮搜索文本
        if self.search_mode:
            self.highlight_search_text()
    
    def prev_segment(self):
        """显示上一段"""
        if self.current_segment_index > 0:
            # 保存当前配置状态
            current_preset_selections = self._save_current_preset_selections()
            global_narration_preset = getattr(self, 'global_narration_preset', None)
            global_narration_emotion = getattr(self, 'global_narration_emotion', None)
            
            # 更新段落索引
            self.current_segment_index -= 1
            
            # 清空现有内容，确保正确重新加载
            for i in reversed(range(self.content_layout.count())):
                widget = self.content_layout.itemAt(i).widget()
                if widget:
                    widget.deleteLater()
            
            # 使用process_current_segment重新分析并加载段落
            self.process_current_segment()
            
            # 恢复全局预设和旁白配置
            self._restore_global_narration_preset(global_narration_preset, global_narration_emotion)
            
            # 更新导航按钮状态
            self.update_nav_buttons()
    
    def next_segment(self):
        """显示下一段"""
        if self.current_segment_index < len(self.segments) - 1:
            # 保存当前配置状态
            current_preset_selections = self._save_current_preset_selections()
            global_narration_preset = getattr(self, 'global_narration_preset', None)
            global_narration_emotion = getattr(self, 'global_narration_emotion', None)
            
            # 更新段落索引
            self.current_segment_index += 1
            
            # 清空现有内容，确保正确重新加载
            for i in reversed(range(self.content_layout.count())):
                widget = self.content_layout.itemAt(i).widget()
                if widget:
                    widget.deleteLater()
            
            # 使用process_current_segment重新分析并加载段落
            self.process_current_segment()
            
            # 恢复全局预设和旁白配置
            self._restore_global_narration_preset(global_narration_preset, global_narration_emotion)
            
            # 更新导航按钮状态
            self.update_nav_buttons()
    
    def _save_current_preset_selections(self):
        """保存当前文本框的预设选择状态"""
        preset_selections = {}
        
        # 遍历内容布局中的所有控件
        for i in range(self.content_layout.count()):
            widget = self.content_layout.itemAt(i).widget()
            # 跳过全局替换框
            if i == 0 and isinstance(widget, QFrame) and "全局文本替换" in widget.findChildren(QLabel)[0].text():
                continue
                
            if isinstance(widget, QFrame):
                # 找到文本框和控制面板
                text_edit = None
                voice_combo = None
                emotion_combo = None
                
                # 查找文本框
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    # 查找文本框容器
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        for k in range(item.layout().count()):
                            sub_item = item.layout().itemAt(k).widget()
                            if isinstance(sub_item, QTextEdit):
                                text_edit = sub_item
                                break
                
                # 查找控制面板
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        control_layout = item.layout()
                        # 查找预设和情绪下拉框
                        found_combos = []
                        for k in range(control_layout.count()):
                            control_item = control_layout.itemAt(k).widget()
                            if isinstance(control_item, QComboBox):
                                found_combos.append(control_item)
                                
                        if len(found_combos) >= 2:
                            voice_combo = found_combos[0]
                            emotion_combo = found_combos[1]
                
                # 如果找到了所有需要的控件，保存预设选择状态
                if text_edit and voice_combo and emotion_combo:
                    text_edit_id = text_edit.objectName()
                    preset_selections[text_edit_id] = {
                        'preset': voice_combo.currentText(),
                        'emotion': emotion_combo.currentText(),
                        'text': text_edit.toPlainText(),
                        'is_narration': 'faf6f1' in widget.styleSheet(),
                        'has_speaker': any(isinstance(w, QLabel) and "说话者" in w.text() 
                                         for w in widget.findChildren(QLabel))
                    }
        
        return preset_selections
    
    def _restore_global_narration_preset(self, global_narration_preset, global_narration_emotion):
        """恢复全局旁白预设选择"""
        if global_narration_preset and global_narration_emotion:
            self.global_narration_preset = global_narration_preset
            self.global_narration_emotion = global_narration_emotion
            
            # 恢复旁白下拉框的选择
            replace_frame = self.content_layout.itemAt(0).widget()
            if replace_frame:
                # 查找旁白预设下拉框
                narration_combos = []
                for child in replace_frame.findChildren(QComboBox):
                    narration_combos.append(child)
                
                if len(narration_combos) >= 2:
                    narration_preset_combo = narration_combos[0]
                    narration_emotion_combo = narration_combos[1]
                    
                    # 恢复选择
                    preset_index = narration_preset_combo.findText(global_narration_preset)
                    if preset_index >= 0:
                        narration_preset_combo.setCurrentIndex(preset_index)
                        
                        # 加载情绪选项
                        emotions = self.preset_manager.get_preset_emotions(global_narration_preset)
                        narration_emotion_combo.clear()
                        narration_emotion_combo.addItems(emotions)
                        
                        # 设置情绪
                        emotion_index = narration_emotion_combo.findText(global_narration_emotion)
                        if emotion_index >= 0:
                            narration_emotion_combo.setCurrentIndex(emotion_index)
    
    def save_text(self):
        """保存当前编辑的文本"""
        current_text = self.text_edit.toPlainText()
        self.processed_segments[self.current_segment_index] = current_text
        QMessageBox.information(self, "提示", "文本已保存")
    
    def copy_text(self):
        """复制当前段落文本到剪贴板"""
        current_text = self.text_edit.toPlainText()
        clipboard = QApplication.clipboard()
        clipboard.setText(current_text)
        QMessageBox.information(self, "提示", "文本已复制到剪贴板")
    
    def replace_text(self):
        """在所有文本中执行替换操作"""
        find_text = self.find_edit.text()
        replace_text = self.replace_edit.text()
        
        if not find_text:
            QMessageBox.warning(self, "提示", "请输入要查找的文本")
            return
        
        # 记录当前编辑的文本
        current_text = self.text_edit.toPlainText()
        self.processed_segments[self.current_segment_index] = current_text
        
        # 执行替换操作
        replace_count = 0
        for i in range(len(self.processed_segments)):
            if find_text in self.processed_segments[i]:
                self.processed_segments[i] = self.processed_segments[i].replace(find_text, replace_text)
                replace_count += self.processed_segments[i].count(replace_text)
        
        # 更新当前显示
        self.update_text_display()
        QMessageBox.information(self, "替换完成", f"共替换了 {replace_count} 处文本")
    
    def generate_preview(self):
        """生成试听音频"""
        # 检查预设
        preset_name = self.preset_combo.currentText()
        if preset_name == "新建预设..." or not preset_name:
            QMessageBox.warning(self, "提示", "请先选择预设")
            return
        
        if not self.current_preset_settings:
            QMessageBox.warning(self, "错误", "请先选择预设")
            return
        
        # 保存当前编辑的文本
        current_text = self.text_edit.toPlainText()
        self.processed_segments[self.current_segment_index] = current_text
        
        # 重置播放状态
        self.player.stop()
        self.play_btn.setText("▶️")
        self.play_btn.setEnabled(False)
        self.preview_progress.setEnabled(False)
        self.preview_progress.setValue(0)
        self.is_generating_preview = True
        self.preview_generated = False
        self.preview_btn.setEnabled(False)
        self.preview_status.setText("🔄 生成中...")
            
        # 加载模型和设置预设参数
        gpt_path = self.current_preset_settings.get('model_path', '') or self.current_preset_settings.get('gpt_path', '')
        if not self.gpt_sovits.load_models(gpt_path, self.current_preset_settings['sovits_path']):
            QMessageBox.warning(self, "错误", "加载模型失败")
            self.reset_preview_state()
            return
            
        # 确保设置包含gpt_sovits.py所需的所有必要字段
        preset_settings = self.current_preset_settings.copy()
        preset_settings['preset_name'] = preset_name  # 添加预设名称
        if 'gpt_path' not in preset_settings and 'model_path' in preset_settings:
            preset_settings['gpt_path'] = preset_settings['model_path']
        if 'ref_language' not in preset_settings:
            preset_settings['ref_language'] = preset_settings.get('text_lang', 'all_zh')
            
        if not self.gpt_sovits.set_preset(preset_settings):
            QMessageBox.warning(self, "错误", "设置预设失败")
            self.reset_preview_state()
            return
        
        # 获取前100字（保持句子完整性）
        text = self.processed_segments[self.current_segment_index]
        preview_text = self.get_preview_text(text)
        
        # 生成试听音频
        logger.info("开始生成预览音频...")
        preview_path = self.gpt_sovits.generate_preview(preview_text)
        
        if preview_path:
            self.preview_path = preview_path
            self.on_preview_generated()
            logger.info("预览音频生成成功")
        else:
            self.reset_preview_state()
            logger.error("预览音频生成失败")
            QMessageBox.warning(self, "错误", "生成试听音频失败")
    
    def reset_preview_state(self):
        """重置预览状态"""
        self.is_generating_preview = False
        self.preview_generated = False
        self.preview_btn.setEnabled(True)
        self.preview_status.setText("❌ 生成失败")
        self.play_btn.setEnabled(False)
        self.preview_progress.setEnabled(False)
        self.preview_progress.setValue(0)
    
    def on_preview_generated(self):
        """预览音频生成完成后的处理"""
        self.is_generating_preview = False
        self.preview_generated = True
        self.preview_btn.setEnabled(True)
        self.play_btn.setEnabled(True)
        self.preview_progress.setEnabled(True)
        self.preview_status.setText("✅ 已生成")
        
    def play_preview(self):
        """播放试听音频"""
        if not self.preview_generated or not hasattr(self, 'preview_path'):
            return
            
        try:
            current_state = self.player.playbackState()
            
            if current_state == QMediaPlayer.PlaybackState.PlayingState:
                # 如果正在播放，暂停
                self.player.pause()
                self.play_btn.setText("▶️")
            else:
                # 🔧 彻底修复播放问题：重新创建播放器实例
                # 这是在macOS上确保QMediaPlayer能重复播放的最可靠方法
                try:
                    # 1. 销毁当前播放器
                    self.player.stop()
                    self.player.setSource(QUrl())  # 清空音频源
                    
                    # 2. 重新创建播放器和音频输出
                    old_volume = self.current_volume
                    del self.player
                    del self.audio_output
                    
                    self.player = QMediaPlayer()
                    self.audio_output = QAudioOutput()
                    self.player.setAudioOutput(self.audio_output)
                    
                    # 3. 恢复音量设置
                    self.audio_output.setVolume(old_volume / 100.0)
                    
                    # 4. 重新连接必要的信号
                    self.player.positionChanged.connect(self.update_position)
                    self.player.durationChanged.connect(self.update_duration)
                    
                    # 5. 连接播放完成信号
                    def on_media_status_changed(status):
                        if status == QMediaPlayer.MediaStatus.EndOfMedia:
                            self.play_btn.setText("▶️")
                    
                    self.player.mediaStatusChanged.connect(on_media_status_changed)
                    
                except Exception as cleanup_error:
                    logger.warning(f"播放器重建时出错，尝试简单重置: {cleanup_error}")
                
                # 6. 设置音频源并播放
                self.player.setSource(QUrl.fromLocalFile(self.preview_path))
                self.player.play()
                self.play_btn.setText("⏸")
                
                logger.info(f"开始播放试听音频: {self.preview_path}")
                
        except Exception as e:
            logger.error(f"播放预览音频时出错: {str(e)}")
    
    def generate_all(self):
        """生成全书音频"""
        # 检查预设
        preset_name = self.preset_combo.currentText()
        if preset_name == "新建预设..." or not preset_name:
            QMessageBox.warning(self, "提示", "请先选择预设")
            return
        
        if not self.current_preset_settings:
            QMessageBox.warning(self, "错误", "请先选择预设")
            return
            
        # 保存当前编辑的文本
        current_text = self.text_edit.toPlainText()
        self.processed_segments[self.current_segment_index] = current_text
            
        # 加载模型和设置预设参数
        gpt_path = self.current_preset_settings.get('model_path', '') or self.current_preset_settings.get('gpt_path', '')
        if not self.gpt_sovits.load_models(gpt_path, self.current_preset_settings['sovits_path']):
            QMessageBox.warning(self, "错误", "加载模型失败")
            return
            
        # 确保设置包含gpt_sovits.py所需的所有必要字段
        preset_settings = self.current_preset_settings.copy()
        preset_settings['preset_name'] = preset_name  # 添加预设名称
        if 'gpt_path' not in preset_settings and 'model_path' in preset_settings:
            preset_settings['gpt_path'] = preset_settings['model_path']
        if 'ref_language' not in preset_settings:
            preset_settings['ref_language'] = preset_settings.get('text_lang', 'all_zh')
            
        if not self.gpt_sovits.set_preset(preset_settings):
            QMessageBox.warning(self, "错误", "设置预设失败")
            return
        
        # 切换到自动生成页面
        parent = self.window()
        if isinstance(parent, MainWindow):
            parent.show_auto_generate_page(self.processed_segments, {
                'preset': preset_name,
                'preset_data': self.current_preset_settings
            })

    
    def get_preview_text(self, text: str, limit: int = 100) -> str:
        """获取预览文本（保持句子完整性）"""
        if len(text) <= limit:
            return text
            
        # 在限制长度位置向后查找句子结束标记
        end_marks = ["。", "！", "？", ".", "!", "?"]
        pos = limit
        while pos < len(text):
            if text[pos] in end_marks:
                return text[:pos + 1]
            pos += 1
        
        # 如果找不到句子结束标记，就在限制长度位置截断
        return text[:limit]
    
    def update_position(self, position):
        """更新播放进度"""
        self.preview_progress.setValue(position)
    
    def update_duration(self, duration):
        """更新音频总长度"""
        self.preview_progress.setRange(0, duration)
    
    def set_position(self, position):
        """设置播放位置"""
        self.player.setPosition(position)

    def search_text(self):
        """搜索文本内容"""
        search_query = self.search_edit.text().strip()
        if not search_query:
            if self.search_mode:
                self.confirm_search()
            return
            
        # 保存当前编辑的文本
        current_text = self.text_edit.toPlainText()
        self.processed_segments[self.current_segment_index] = current_text
        
        # 搜索所有段落
        self.search_results = []
        for i, segment in enumerate(self.processed_segments):
            if search_query.lower() in segment.lower():  # 不区分大小写搜索
                self.search_results.append(i)
        
        if not self.search_results:
            if self.search_mode:
                self.confirm_search()
            QMessageBox.information(self, "搜索结果", "未找到匹配内容")
            return
            
        # 进入搜索模式
        self.search_mode = True
        self.last_search_query = search_query
        
        # 如果当前段落包含搜索内容，保持在当前段落
        if self.current_segment_index in self.search_results:
            self.search_index = self.search_results.index(self.current_segment_index)
        else:
            self.search_index = 0
            self.current_segment_index = self.search_results[0]
            
        self.confirm_search_btn.setEnabled(True)
        self.confirm_search_btn.setText(f"退出搜索 ({len(self.search_results)}个结果)")
        self.update_text_display()

    def on_search_text_changed(self, text):
        """当搜索框文本改变时实时搜索"""
        if not text.strip():
            if self.search_mode:
                self.confirm_search()
            return
            
        if text.strip() != self.last_search_query:
            self.search_text()

    def highlight_search_text(self):
        """高亮显示搜索文本"""
        if not self.search_mode:
            return
            
        search_query = self.search_edit.text().lower()  # 转换为小写以进行不区分大小写的搜索
        text = self.text_edit.toPlainText()
        
        cursor = self.text_edit.textCursor()
        # 清除之前的格式
        cursor.select(cursor.Document)
        cursor.setCharFormat(QTextCharFormat())
        cursor.clearSelection()
        
        # 设置高亮格式
        highlight_format = QTextCharFormat()
        highlight_format.setBackground(QColor("#FFFF00"))  # 黄色背景
        
        # 查找并高亮所有匹配项
        text_lower = text.lower()  # 转换为小写进行搜索
        start = 0
        while True:
            start = text_lower.find(search_query, start)
            if start == -1:
                break
                
            cursor.setPosition(start)
            cursor.setPosition(start + len(search_query), cursor.KeepAnchor)
            cursor.setCharFormat(highlight_format)
            
            start += len(search_query)
    
    def confirm_search(self):
        """确认搜索，退出搜索模式"""
        self.search_mode = False
        self.search_results = []
        self.search_index = 0
        self.last_search_query = ""
        self.search_edit.clear()
        self.confirm_search_btn.setEnabled(False)
        self.confirm_search_btn.setText("退出搜索")
        
        # 清除高亮
        cursor = self.text_edit.textCursor()
        cursor.select(cursor.Document)
        cursor.setCharFormat(QTextCharFormat())
        cursor.clearSelection()
        
        # 更新显示
        self.update_text_display()

    def check_system_volume(self):
        """检查系统音量变化并更新音频播放器"""
        try:
            # 获取系统音量
            system_volume = int(QMediaDevices.defaultAudioOutput().volume() * 100)
            
            # 如果系统音量与当前音量不同，更新音量设置
            if system_volume != self.current_volume:
                # 更新滑块显示
                self.volume_slider.setValue(system_volume)
                # 更新音频输出音量
                self.audio_output.setVolume(system_volume / 100.0)
                # 保存当前音量设置
                self.current_volume = system_volume
        except Exception as e:
            # 如果获取系统音量失败，则不做处理
            pass

class AutoGenerateCard(Card):
    def __init__(self, segments: List[str], settings: dict, parent=None):
        super().__init__(parent)
        self.segments = segments
        self.preset_name = settings['preset']
        self.preset_data = settings['preset_data']
        self.current_segment_index = 0
        self.is_generating = False
        self.gpt_sovits = GPTSoVITS()
        
        # 添加前一个段落长度记录
        self.prev_segment_length = 0
        
        # 添加文件名和目录相关属性
        self.main_window = self.window()
        self.source_filename = "unknown"
        if hasattr(self.main_window, 'current_file') and self.main_window.current_file:
            self.source_filename = os.path.splitext(os.path.basename(self.main_window.current_file))[0]
        
        # 获取主窗口的批处理字数设置
        if isinstance(self.main_window, MainWindow):
            self.batch_size = self.main_window.batch_spin.value()
        else:
            self.batch_size = 5000  # 默认值
        
        # 所有生成的音频文件路径列表
        self.generated_audio_files = []
        
        self.init_ui()
        
        # 加载模型
        gpt_path = self.preset_data.get('model_path', '') or self.preset_data.get('gpt_path', '')
        if not self.gpt_sovits.load_models(gpt_path, self.preset_data['sovits_path']):
            QMessageBox.warning(self, "错误", "加载模型失败")
            return
            
        # 设置预设参数
        # 确保设置包含gpt_sovits.py所需的所有必要字段
        preset_settings = self.preset_data.copy()
        preset_settings['preset_name'] = self.preset_name  # 添加预设名称
        if 'gpt_path' not in preset_settings and 'model_path' in preset_settings:
            preset_settings['gpt_path'] = preset_settings['model_path']
        if 'ref_language' not in preset_settings:
            preset_settings['ref_language'] = preset_settings.get('text_lang', 'all_zh')
            
        if not self.gpt_sovits.set_preset(preset_settings):
            QMessageBox.warning(self, "错误", "设置预设失败")
            return

    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(20)
        
        # 状态显示
        self.status_label = QLabel("正在生成...")
        self.status_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        
        # 进度条
        self.progress = QProgressBar()
        self.progress.setRange(0, len(self.segments))
        self.progress.setValue(0)
        
        # 当前处理的文本预览
        preview_group = QGroupBox("当前处理文本")
        preview_layout = QVBoxLayout(preview_group)
        self.preview_text = QTextEdit()
        self.preview_text.setReadOnly(True)
        self.preview_text.setMaximumHeight(100)
        preview_layout.addWidget(self.preview_text)
        
        # 添加组件到布局
        layout.addWidget(self.status_label, alignment=Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.progress)
        layout.addWidget(preview_group)
        
        # 开始生成
        QTimer.singleShot(100, self.start_generate)
    
    def start_generate(self):
        """开始生成全书音频"""
        try:
            # 设置预设
            preset_settings = self.preset_data.copy()
            preset_settings['preset_name'] = self.preset_name  # 添加预设名称
            if not self.gpt_sovits.set_preset(preset_settings):
                raise Exception("设置预设失败")
            
            # 创建输出目录结构
            working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
            processed_dir = os.path.join(working_dir, f"{self.source_filename}_processed")
            
            # 创建audio_segments目录
            self.audio_dir = os.path.join(processed_dir, "audio_segments")
            os.makedirs(self.audio_dir, exist_ok=True)
            
            # 创建merged_segments目录
            self.merged_dir = os.path.join(processed_dir, "merged_segments")
            os.makedirs(self.merged_dir, exist_ok=True)
            
            self.process_next_segment()
            
        except Exception as e:
            QMessageBox.critical(self, "错误", f"开始生成失败: {str(e)}")
            self.on_generation_complete()
    
    def process_next_segment(self):
        """处理下一个段落"""
        if self.current_segment_index >= len(self.segments):
            self.on_generation_complete()
            return
        
        # 更新显示
        current_text = self.segments[self.current_segment_index]
        # 显示预览文本（限制长度以便阅读）
        preview_text = self.get_preview_text(current_text, 200)
        self.preview_text.setText(preview_text)
        self.progress.setValue(self.current_segment_index)
        
        # 强制刷新UI
        QApplication.processEvents()
        
        # 记录当前段落长度，供下一次生成使用
        self.prev_segment_length = len(current_text)
        
        # 生成音频路径使用多人模式的命名格式
        output_path = os.path.join(
            self.audio_dir,
            f"{self.source_filename}_段落{self.current_segment_index + 1}_文本框1.wav"
        )
        
        # 使用QTimer异步生成音频，避免阻塞UI
        QTimer.singleShot(100, lambda: self.generate_current_segment(output_path))
    
    def generate_current_segment(self, output_path: str):
        """生成当前段落的音频"""
        try:
            # 生成音频
            success = self.gpt_sovits.generate_audio(
                self.segments[self.current_segment_index],
                output_path
            )
            
            if success:
                # 添加生成的文件到列表
                self.generated_audio_files.append(output_path)
                self.current_segment_index += 1
                
                # 添加基于前一个段落长度的延迟，然后处理下一个段落
                if self.current_segment_index < len(self.segments):
                    delay_ms = max(100, self.prev_segment_length // 2)  # 最少100ms延迟
                    QTimer.singleShot(delay_ms, self.process_next_segment)
                else:
                    self.on_generation_complete()
            else:
                QMessageBox.critical(self, "错误", f"生成第 {self.current_segment_index + 1} 段失败")
                self.on_generation_complete()
                
        except Exception as e:
            QMessageBox.critical(self, "错误", f"生成第 {self.current_segment_index + 1} 段时出错: {str(e)}")
            self.on_generation_complete()
    
    def get_preview_text(self, text: str, limit: int = 200) -> str:
        """获取预览文本（保持句子完整性）"""
        if len(text) <= limit:
            return text
            
        # 在限制长度位置向后查找句子结束标记
        end_marks = ["。", "！", "？", ".", "!", "?"]
        pos = limit
        while pos < len(text):
            if text[pos] in end_marks:
                return text[:pos + 1] + "..."
            pos += 1
            
        # 如果找不到句子结束标记，直接截断
        return text[:limit] + "..."
    
    def on_generation_complete(self):
        """全部生成完成"""
        self.status_label.setText("✅ 生成完成！")
        self.progress.setValue(len(self.segments))
        
        if self.current_segment_index == len(self.segments):
            # 自动进行音频合并
            self.merge_segment_audio()
            QMessageBox.information(self, "生成完成", f"全书音频生成完成！\n输出目录：{self.audio_dir}\n已自动合并音频到：{self.merged_dir}")
        else:
            QMessageBox.warning(self, "生成中断", f"生成在第 {self.current_segment_index + 1} 段中断")
        
        # 返回主页面
        parent = self.window()
        if isinstance(parent, MainWindow):
            parent.show_main_page()
            
    def merge_segment_audio(self):
        """合并音频段落为更大的块"""
        try:
            # 计算合并规则：10000/分批处理字数
            segments_per_file = int(10000 / self.batch_size)
            if segments_per_file < 1:
                segments_per_file = 1
                
            self.status_label.setText("合并音频...")
            
            # 使用pydub合并音频
            from pydub import AudioSegment
            
            # 对生成的文件进行排序
            self.generated_audio_files.sort()
            total_files = len(self.generated_audio_files)
            
            # 创建一个进度对话框
            progress = QProgressDialog("正在合并音频...", "取消", 0, total_files // segments_per_file + 1, self)
            progress.setWindowTitle("音频合并")
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setMinimumWidth(300)
            progress.show()
            
            # 按segments_per_file的数量分组合并
            for group_idx in range(0, total_files, segments_per_file):
                progress.setValue(group_idx // segments_per_file)
                progress.setLabelText(f"正在合并组 {group_idx // segments_per_file + 1}/{(total_files // segments_per_file) + 1}")
                
                if progress.wasCanceled():
                    break
                    
                # 获取当前组的文件
                group_files = self.generated_audio_files[group_idx:group_idx + segments_per_file]
                if not group_files:
                    continue
                    
                # 合并音频
                combined = AudioSegment.empty()
                for audio_file in group_files:
                    segment = AudioSegment.from_wav(audio_file)
                    combined += segment
                
                # 生成输出文件名
                output_file = os.path.join(
                    self.merged_dir,
                    f"{self.source_filename}_合并{group_idx // segments_per_file + 1}.wav"
                )
                
                # 导出合并后的音频
                combined.export(output_file, format="wav")
                
                # 处理事件，保持UI响应
                QApplication.processEvents()
                
            progress.close()
            
        except Exception as e:
            QMessageBox.critical(self, "错误", f"合并音频失败: {str(e)}")

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.text_processor = TextProcessor()
        self.preset_manager = PresetManager()
        self.preset_order_manager = PresetOrderManager()  # 添加预设排序管理器
        self.initUI()

    def initUI(self):
        self.setWindowTitle('GPT-SoVITS 文本处理')
        self.setStyleSheet(StyleSheet.MAIN_STYLE)
        
        # 🔧 固定窗口大小并增加高度
        # 原来: 864x558, 现在: 864x1081 (减少0.5cm约19px)
        # 为macOS顶部菜单栏预留空间
        fixed_width = 864
        fixed_height = 1081
        
        # 设置固定窗口大小，禁止调整
        self.setFixedSize(fixed_width, fixed_height)
        
        # 🔧 固定字体大小定义
        base_font_size = 12
        
        # 设置窗口字体 - 使用固定字体大小
        font = QFont("SF Pro Display", base_font_size)
        self.setFont(font)

        # 创建主窗口部件和滚动区域
        main_widget = QWidget()
        scroll_area = QScrollArea()
        scroll_area.setWidget(main_widget)
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #faf6f1;  /* 护眼米色背景 */
            }
            QScrollArea > QWidget > QWidget {
                background-color: #faf6f1;  /* 确保内容区域也是米色 */
            }
            QScrollBar:vertical {
                border: none;
                background: #f0f0f0;
                width: 10px;
                border-radius: 5px;
            }
            QScrollBar::handle:vertical {
                background: #C67A8A;
                border-radius: 5px;
                min-height: 20px;
            }
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar::add-page:vertical,
            QScrollBar::sub-page:vertical {
                background: none;
            }
        """)
        self.setCentralWidget(scroll_area)
        
        # 主布局 - 使用相对间距
        layout = QVBoxLayout(main_widget)
        layout.setSpacing(int(self.width() * 0.012))  # 间距为窗口宽度的1.2%
        layout.setContentsMargins(
            int(self.width() * 0.017),  # 左边距为窗口宽度的1.7%
            int(self.height() * 0.027),  # 上边距为窗口高度的2.7%
            int(self.width() * 0.017),   # 右边距为窗口宽度的1.7%
            int(self.height() * 0.027)    # 下边距为窗口高度的2.7%
        )

        # 顶部按钮区域
        top_layout = QHBoxLayout()
        self.add_preset_btn = QPushButton('新建预设')
        # 🔧 使用固定的按钮尺寸，统一设为32px高度
        button_height = 32
        self.add_preset_btn.setFixedHeight(button_height)
        self.add_preset_btn.setMaximumWidth(120)  # 限制最大宽度避免过宽
        
        # 添加模型缓存管理按钮
        self.cache_status_btn = QPushButton('缓存状态')
        self.cache_status_btn.setFixedHeight(button_height)
        self.cache_status_btn.setMaximumWidth(120)
        
        self.clear_cache_btn = QPushButton('清空缓存')
        self.clear_cache_btn.setFixedHeight(button_height) 
        self.clear_cache_btn.setMaximumWidth(120)
        
        top_layout.addWidget(self.add_preset_btn)
        top_layout.addStretch()
        top_layout.addWidget(self.cache_status_btn)
        top_layout.addWidget(self.clear_cache_btn)

        # 堆叠窗口用于切换界面
        self.stack = QStackedWidget()
        
        # 文本处理页面
        text_page = QWidget()
        text_layout = QVBoxLayout(text_page)
        text_layout.setSpacing(int(self.width() * 0.012))
        
        # 文本处理区域
        text_card = Card()
        card_layout = QVBoxLayout(text_card)
        card_layout.setSpacing(int(self.width() * 0.009))
        
        # 文件选择区域
        file_layout = QHBoxLayout()
        self.file_btn = QPushButton('📄 选择文件')
        self.file_btn.setMinimumHeight(int(self.height() * 0.05))
        self.file_path_label = QLabel('未选择文件')
        self.file_path_label.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.9)}px;")
        file_layout.addWidget(self.file_btn)
        file_layout.addWidget(self.file_path_label)
        file_layout.addStretch()
        
        # 文本预览区域
        preview_group = QGroupBox("文本预览")
        preview_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(self.height() * 0.02)}px;
                margin-top: {int(self.height() * 0.014)}px;
            }}
        """)
        preview_layout = QVBoxLayout(preview_group)
        preview_layout.setContentsMargins(
            int(self.width() * 0.009),
            int(self.height() * 0.014),
            int(self.width() * 0.009),
            int(self.height() * 0.014)
        )
        self.preview_text = QTextEdit()
        self.preview_text.setPlaceholderText("这里将显示文件内容预览...")
        self.preview_text.setReadOnly(True)
        # 预览文本框高度设置为窗口高度的30%
        self.preview_text.setMinimumHeight(int(self.height() * 0.3))
        preview_layout.addWidget(self.preview_text)
        
        # 处理选项
        options_group = QGroupBox("处理选项")
        options_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(self.height() * 0.02)}px;
                margin-top: {int(self.height() * 0.014)}px;
            }}
        """)
        options_layout = QGridLayout(options_group)
        options_layout.setSpacing(int(self.width() * 0.009))
        options_layout.setContentsMargins(
            int(self.width() * 0.009),
            int(self.height() * 0.014),
            int(self.width() * 0.009),
            int(self.height() * 0.014)
        )
        
        # 文本转换选项
        convert_label = QLabel("文本转换")
        convert_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.convert_check = QCheckBox("转换为txt格式")
        self.convert_check.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.convert_check.setChecked(True)
        self.convert_check.setEnabled(False)
        convert_note = QLabel("epub和pdf文件会自动转换为txt格式")
        convert_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        options_layout.addWidget(convert_label, 0, 0)
        options_layout.addWidget(self.convert_check, 0, 1)
        options_layout.addWidget(convert_note, 0, 2)
        
        # 英文处理选项
        english_label = QLabel("英文处理")
        english_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.english_check = QCheckBox("去除英文内容")
        self.english_check.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.english_check.setChecked(True)
        english_note = QLabel("去除所有英文以及被括号、引号等包含的英文（含标点符号）")
        english_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        options_layout.addWidget(english_label, 1, 0)
        options_layout.addWidget(self.english_check, 1, 1)
        options_layout.addWidget(english_note, 1, 2)
        
        # 单次处理字数
        batch_label = QLabel("单次处理字数")
        batch_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.batch_spin = QSpinBox()
        self.batch_spin.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.batch_spin.setRange(100, 1000000)  # 设置为非常大的值，实际上没有上限
        self.batch_spin.setSingleStep(1000)
        self.batch_spin.setValue(10000)
        batch_note = QLabel("每次处理的文本长度，默认10000字，可根据需要调整")
        batch_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        options_layout.addWidget(batch_label, 2, 0)
        options_layout.addWidget(self.batch_spin, 2, 1)
        options_layout.addWidget(batch_note, 2, 2)
        
        # 听书模式选项
        mode_label = QLabel("听书模式")
        mode_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        mode_widget = QWidget()
        mode_buttons_layout = QHBoxLayout(mode_widget)
        self.single_radio = QRadioButton("单人朗读")
        self.multi_radio = QRadioButton("多人朗读")
        self.single_radio.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.multi_radio.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.multi_radio.setChecked(True)  # 默认为多人朗读模式
        mode_buttons_layout.addWidget(self.single_radio)
        mode_buttons_layout.addWidget(self.multi_radio)
        mode_buttons_layout.addStretch()
        mode_note = QLabel("选择单人朗读或多人分角色朗读")
        mode_note.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
        options_layout.addWidget(mode_label, 3, 0)
        options_layout.addWidget(mode_widget, 3, 1)
        options_layout.addWidget(mode_note, 3, 2)
        
        # 添加所有组件到文本处理布局
        card_layout.addLayout(file_layout)
        card_layout.addWidget(preview_group)
        card_layout.addWidget(options_group)
        
        # 底部按钮
        button_layout = QHBoxLayout()
        self.process_btn = QPushButton('处理文本')
        self.process_btn.setObjectName("generate_btn")
        self.process_btn.setMinimumHeight(int(self.height() * 0.05))
        button_layout.addStretch()
        button_layout.addWidget(self.process_btn)
        
        # 添加所有组件到文本处理页面
        text_layout.addWidget(text_card)
        text_layout.addLayout(button_layout)
        
        # 预设设置页面
        preset_page = QWidget()
        preset_layout = QVBoxLayout(preset_page)
        
        # 添加页面到堆叠窗口
        self.stack.addWidget(text_page)
        self.stack.addWidget(preset_page)
        
        # 添加所有组件到主布局
        layout.addLayout(top_layout)
        layout.addWidget(self.stack)
        
        # 连接信号
        self.file_btn.clicked.connect(self.select_file)
        self.process_btn.clicked.connect(self.process_text)
        self.add_preset_btn.clicked.connect(self.show_preset_setting)
        self.cache_status_btn.clicked.connect(self.show_cache_status)
        self.clear_cache_btn.clicked.connect(self.clear_model_cache)
        
        # 添加窗口大小变化事件处理
        self.resizeEvent = self.on_resize
    
    def on_resize(self, event):
        """处理窗口大小变化事件"""
        # 更新基础字体大小
        base_font_size = max(12, int(self.width() / 72))
        
        # 更新所有组件的字体大小
        for widget in self.findChildren(QLabel):
            if isinstance(widget, QLabel):
                if "note" in widget.objectName():
                    widget.setStyleSheet(f"color: #666; font-size: {int(base_font_size * 0.85)}px;")
                else:
                    widget.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        
        for widget in self.findChildren((QLineEdit, QPushButton, QComboBox, QSpinBox, QDoubleSpinBox)):
            widget.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        
        # 更新组框样式
        for group_box in self.findChildren(QGroupBox):
            group_box.setStyleSheet(f"""
                QGroupBox {{
                    font-size: {int(base_font_size * 1.1)}px;
                    font-weight: 500;
                    padding-top: {int(self.height() * 0.02)}px;
                    margin-top: {int(self.height() * 0.014)}px;
                }}
            """)
        
        # 更新按钮高度
        self.add_preset_btn.setMinimumHeight(int(self.height() * 0.05))
        self.process_btn.setMinimumHeight(int(self.height() * 0.05))
        self.cache_status_btn.setMinimumHeight(int(self.height() * 0.05))
        self.clear_cache_btn.setMinimumHeight(int(self.height() * 0.05))
        
        super().resizeEvent(event)
    
    def show_preset_setting(self, preset_name: str = None, source_page: str = "main"):
        """显示预设设置页面"""
        self.source_page = source_page  # 记录来源页面
        
        # 🔧 为预设设置页面添加滚动支持
        # 创建一个容器widget包装PresetSettingCard
        scroll_container = QWidget()
        scroll_area = QScrollArea()
        preset_card = PresetSettingCard(self.preset_manager, self.preset_order_manager, preset_name, source_page, self)
        
        # 设置滚动区域
        scroll_area.setWidget(preset_card)
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setStyleSheet("""
            QScrollArea {
                border: none;
                background: transparent;
            }
            QScrollBar:vertical {
                background: #f0f0f0;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background: #c0c0c0;
                min-height: 20px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical:hover {
                background: #a0a0a0;
            }
        """)
        
        # 将滚动区域包装在容器中
        container_layout = QVBoxLayout(scroll_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.addWidget(scroll_area)
        
        self.stack.addWidget(scroll_container)
        self.stack.setCurrentWidget(scroll_container)
    
    def show_main_page(self):
        """返回主页面"""
        # 如果是从段落处理页面跳转过来的，则返回段落处理页面
        if hasattr(self, 'source_page') and self.source_page == "segment":
            for i in range(self.stack.count()):
                widget = self.stack.widget(i)
                if isinstance(widget, SegmentProcessCard):
                    # 如果段落处理卡片有保存的状态，则恢复
                    if hasattr(widget, 'saved_segment_index'):
                        widget.current_segment_index = widget.saved_segment_index
                        # 如果有保存预设选择状态，则恢复
                        if hasattr(widget, 'saved_preset_selections'):
                            # 首先处理当前段落
                            widget.process_current_segment()
                            
                            # 恢复全局旁白预设（如果有）
                            if hasattr(widget, 'saved_global_narration_preset') and widget.saved_global_narration_preset:
                                widget._restore_global_narration_preset(
                                    widget.saved_global_narration_preset, 
                                    widget.saved_global_narration_emotion
                                )
                            
                            # 恢复各文本框的预设选择
                            for i in range(widget.content_layout.count()):
                                w = widget.content_layout.itemAt(i).widget()
                                # 跳过全局替换框
                                if i == 0 and isinstance(w, QFrame) and "全局文本替换" in w.findChildren(QLabel)[0].text():
                                    continue
                                    
                                if isinstance(w, QFrame):
                                    # 找到文本框和控制面板
                                    text_edit = None
                                    voice_combo = None
                                    emotion_combo = None
                                    
                                    # 查找文本框
                                    for j in range(w.layout().count()):
                                        item = w.layout().itemAt(j).widget()
                                        # 查找文本框容器
                                        if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                                            for k in range(item.layout().count()):
                                                sub_item = item.layout().itemAt(k).widget()
                                                if isinstance(sub_item, QTextEdit):
                                                    text_edit = sub_item
                                                    break
                                    
                                    # 查找控制面板
                                    for j in range(w.layout().count()):
                                        item = w.layout().itemAt(j).widget()
                                        if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                                            control_layout = item.layout()
                                            # 查找预设和情绪下拉框
                                            found_combos = []
                                            for k in range(control_layout.count()):
                                                control_item = control_layout.itemAt(k).widget()
                                                if isinstance(control_item, QComboBox):
                                                    found_combos.append(control_item)
                                                    
                                            if len(found_combos) >= 2:
                                                voice_combo = found_combos[0]
                                                emotion_combo = found_combos[1]
                                        
                                    # 如果找到了所有需要的控件，尝试恢复预设选择状态
                                    if text_edit and voice_combo and emotion_combo:
                                        text_edit_id = text_edit.objectName()
                                        # 首先尝试精确匹配ID
                                        if text_edit_id in widget.saved_preset_selections:
                                            # 恢复预设选择
                                            preset_info = widget.saved_preset_selections[text_edit_id]
                                            preset = preset_info['preset']
                                            preset_index = voice_combo.findText(preset)
                                            if preset_index >= 0:
                                                voice_combo.setCurrentIndex(preset_index)
                                                
                                                # 恢复情绪选择
                                                emotion = preset_info['emotion']
                                                emotions = widget.preset_manager.get_preset_emotions(preset)
                                                emotion_combo.clear()
                                                emotion_combo.addItems(emotions)
                                                
                                                emotion_index = emotion_combo.findText(emotion)
                                                if emotion_index >= 0:
                                                    emotion_combo.setCurrentIndex(emotion_index)
                        else:
                            # 没有保存的预设选择状态，只处理当前段落
                            widget.process_current_segment()
                            
                        # 更新导航按钮状态
                        widget.update_nav_buttons()
                    self.stack.setCurrentWidget(widget)
                    return
        
        # 默认回到主页面
        self.stack.setCurrentIndex(0)
        
        # 恢复顶部按钮的可见性
        self.add_preset_btn.setVisible(True)
        self.process_btn.setVisible(True)
        self.cache_status_btn.setVisible(True)
        self.clear_cache_btn.setVisible(True)

    def select_file(self):
        # 设置Working目录作为默认目录
        working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
        os.makedirs(working_dir, exist_ok=True)  # 确保Working目录存在
        
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "选择文件",
            working_dir,  # 将默认目录设置为Working目录
            "支持的文件 (*.txt *.epub *.pdf);;文本文件 (*.txt);;EPUB文件 (*.epub);;PDF文件 (*.pdf)"
        )
        if file_name:
            # 获取原始文件信息
            base_name = os.path.splitext(os.path.basename(file_name))[0]
            working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
            
            # 使用原始选择的文件
            self.current_file = file_name
            self.file_path_label.setText(os.path.basename(file_name))
            self.load_file_preview(file_name)
    
    def load_file_preview(self, file_path):
        """加载文件预览"""
        try:
            # 先转换文件
            preview_text = self.text_processor.convert_to_txt(file_path)
            if preview_text:
                # 只显示前1000个字符
                preview = preview_text[:1000]
                if len(preview_text) > 1000:
                    preview += "\n...(更多内容已省略)"
                self.preview_text.setText(preview)
            else:
                self.preview_text.setText("文件预览失败：无法读取文件内容")
        except Exception as e:
            self.preview_text.setText(f"文件预览失败：{str(e)}")
    
    def process_text(self):
        """处理文本"""
        if not hasattr(self, 'current_file'):
            QMessageBox.warning(self, "提示", "请先选择文件")
            return
        
        # 检查是否有预设
        presets = self.preset_manager.get_all_presets()
        if not presets:
            QMessageBox.warning(self, "提示", "请先在主页面创建至少一个预设")
            return
        
        try:
            # 获取处理设置
            settings = {
                'remove_english': self.english_check.isChecked(),
                'batch_size': self.batch_spin.value(),
                'is_multi_speaker': self.multi_radio.isChecked()
            }
            
            # 获取文件基本信息
            base_name = os.path.splitext(os.path.basename(self.current_file))[0]
            
            # 检查Working目录中是否有已处理的同名文件
            working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
            processed_dir = os.path.join(working_dir, f"{base_name}_processed")
            segments_file = os.path.join(processed_dir, "segments.txt")
            
            
            
            # 显示进度条
            progress = QProgressBar(self)
            progress.setWindowTitle("处理中")
            progress.setRange(0, 100)
            progress.setValue(0)
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setMinimumWidth(300)
            progress.show()
            
            # 先转换文件
            text = self.text_processor.convert_to_txt(self.current_file)
            if not text:
                QMessageBox.warning(self, "错误", "文件转换失败")
                progress.hide()
                return
            
            # 处理文本
            segments = self.text_processor.process_text_with_progress(
                text, 
                settings,
                lambda p: progress.setValue(p)
            )
            

            if not segments:
                QMessageBox.warning(self, "错误", "文本处理失败：未能获取有效内容")
                progress.hide()
                return
            
            # 保存原始文件到Working目录
            os.makedirs(working_dir, exist_ok=True)
            original_file_path = os.path.join(working_dir, os.path.basename(self.current_file))
            if os.path.abspath(self.current_file) != os.path.abspath(original_file_path):
                shutil.copy2(self.current_file, original_file_path)
            
            # 保存处理结果到Working目录
            os.makedirs(processed_dir, exist_ok=True)
            
            # 保存分段文本
            with open(segments_file, 'w', encoding='utf-8') as f:
                for i, segment in enumerate(segments, 1):
                    f.write(f"[段落 {i}]\n{segment}\n\n")
            
            # 隐藏进度条
            progress.hide()
            
            # 根据模式切换到相应的处理页面
            if settings['is_multi_speaker']:
                # 🔧 在进入角色统计前询问用户是否需要角色统计
                reply = QMessageBox.question(
                    self, 
                    "角色统计选择", 
                    "是否需要进行角色统计？\n\n"
                    "• 点击「是」：进入角色统计页面，自动分析文本中的角色\n"
                    "• 点击「否」：跳过角色统计，直接进入多人对话处理页面",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.Yes  # 默认选择"是"
                )
                
                if reply == QMessageBox.StandardButton.Yes:
                    # 用户选择进行角色统计
                    self.show_multi_speaker_preprocess_page(segments)
                else:
                    # 用户选择跳过角色统计，直接进入对话处理页面
                    # 创建空的角色列表，直接进入段落处理页面
                    self.show_segment_process_page(segments, [])
            else:
                self.show_single_speaker_page(segments)
        
        except Exception as e:
            # 确保进度条被关闭
            if 'progress' in locals():
                progress.hide()
            QMessageBox.critical(self, "错误", f"处理文本时出错：{str(e)}")
    
    def has_multiple_speakers(self, segments: List[str]) -> bool:
        """检查是否有多个说话者"""
        speaker_set = set()
        for _, _, speaker in segments:
            if speaker:
                speaker_set.add(speaker)
        return len(speaker_set) > 1
    
    def show_single_speaker_page(self, segments: List[str]):
        """显示单人朗读页面"""
        single_speaker_page = QWidget()
        layout = QVBoxLayout(single_speaker_page)
        single_speaker_card = FirstSegmentCard(segments, self.preset_manager, self.preset_order_manager)
        layout.addWidget(single_speaker_card)
        
        # 添加页面到堆叠窗口
        self.stack.addWidget(single_speaker_page)
        self.stack.setCurrentWidget(single_speaker_page)
        
        # 隐藏顶部按钮
        self.add_preset_btn.setVisible(False)
        self.process_btn.setVisible(False)
        self.cache_status_btn.setVisible(False)
        self.clear_cache_btn.setVisible(False)
        
    def show_auto_generate_page(self, segments: List[str], settings: dict):
        """显示自动生成页面"""
        auto_generate_page = QWidget()
        layout = QVBoxLayout(auto_generate_page)
        auto_generate_card = AutoGenerateCard(segments, settings)
        layout.addWidget(auto_generate_card)
        
        # 添加页面到堆叠窗口
        self.stack.addWidget(auto_generate_page)
        self.stack.setCurrentWidget(auto_generate_page)
        
        # 隐藏顶部按钮
        self.add_preset_btn.setVisible(False)
        self.process_btn.setVisible(False)
        self.cache_status_btn.setVisible(False)
        self.clear_cache_btn.setVisible(False)

    def load_presets(self):
        """更新预设列表"""
        # 获取当前显示的卡片
        current_widget = self.stack.currentWidget()
        
        # 如果是FirstSegmentCard，更新其预设列表
        if isinstance(current_widget, FirstSegmentCard):
            current_widget.load_presets()

    def show_multi_speaker_preprocess_page(self, segments: List[str]):
        """显示多人朗读预处理页面"""
        multi_speaker_preprocess_page = QWidget()
        layout = QVBoxLayout(multi_speaker_preprocess_page)
        
        # 创建卡片前先设置好布局
        multi_speaker_preprocess_page.setLayout(layout)
        
        # 创建卡片
        multi_speaker_preprocess_card = MultiSpeakerPreprocessCard(segments, self.preset_manager, self.preset_order_manager)
        layout.addWidget(multi_speaker_preprocess_card)
        
        # 添加页面到堆叠窗口
        self.stack.addWidget(multi_speaker_preprocess_page)
        self.stack.setCurrentWidget(multi_speaker_preprocess_page)
        
        # 隐藏顶部按钮
        self.add_preset_btn.setVisible(False)
        self.process_btn.setVisible(False)
        self.cache_status_btn.setVisible(False)
        self.clear_cache_btn.setVisible(False)

    def show_multi_speaker_page(self, processed_segments: List[str]):
        """显示多人朗读页面"""
        # TODO: 实现多人朗读页面
        pass

    def show_segment_process_page(self, segments: List[str], characters: List[Tuple[str, str]]):
        """显示分段处理页面"""
        segment_process_page = QWidget()
        layout = QVBoxLayout(segment_process_page)
        
        segment_process_card = SegmentProcessCard(segments, characters, self.preset_manager, self.preset_order_manager)
        layout.addWidget(segment_process_card)
        
        # 添加页面到堆叠窗口
        self.stack.addWidget(segment_process_page)
        self.stack.setCurrentWidget(segment_process_page)
        
        # 隐藏顶部按钮
        self.add_preset_btn.setVisible(False)
        self.process_btn.setVisible(False)
        self.cache_status_btn.setVisible(False)
        self.clear_cache_btn.setVisible(False)
    
    def show_cache_status(self):
        """显示模型缓存状态"""
        try:
            cache = get_global_model_cache()
            cache_info = cache.get_cache_info()
            
            # 构建状态信息
            status_text = f"""模型缓存状态：

缓存统计：
• 已缓存模型数: {cache_info['cached_models']}/{cache_info['max_models']}
• 缓存命中次数: {cache_info['cache_hits']}
• 缓存未命中次数: {cache_info['cache_misses']}
• 缓存命中率: {cache_info['hit_rate']:.1%}

已缓存的模型："""
            
            if cache_info['cached_model_list']:
                for i, model_info in enumerate(cache_info['cached_model_list'], 1):
                    status_text += f"""
{i}. {model_info['key']}
   GPT: {model_info['gpt_model']}
   SoVITS: {model_info['sovits_model']}
   最后使用: {model_info['last_used']}"""
            else:
                status_text += "\n• 无已缓存的模型"
            
            # 添加内存使用建议
            status_text += f"""

内存使用建议：
• 推荐最大缓存模型数: 3个（适用于16GB内存）
• 当前设置: {cache_info['max_models']}个
• 每个模型大约占用2-4GB内存"""
            
            QMessageBox.information(self, "模型缓存状态", status_text)
            
        except Exception as e:
            QMessageBox.critical(self, "错误", f"获取缓存状态失败: {str(e)}")
    
    def clear_model_cache(self):
        """清空模型缓存"""
        try:
            # 确认操作
            reply = QMessageBox.question(
                self, 
                "确认清空缓存", 
                "确定要清空所有模型缓存吗？\n\n这将释放内存，但下次使用模型时需要重新加载。",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                cache = get_global_model_cache()
                
                # 获取清空前的状态
                before_info = cache.get_cache_info()
                
                # 清空缓存
                cache.clear_cache()
                
                # 显示结果
                QMessageBox.information(
                    self, 
                    "缓存已清空", 
                    f"已成功清空模型缓存！\n\n清空前: {before_info['cached_models']}个模型\n清空后: 0个模型\n\n内存已释放，下次使用模型时将重新加载。"
                )
                
        except Exception as e:
            QMessageBox.critical(self, "错误", f"清空缓存失败: {str(e)}")

class MultiSpeakerPreprocessCard(Card):
    def __init__(self, segments: List[str], preset_manager: PresetManager, preset_order_manager: PresetOrderManager = None, parent=None):
        super().__init__(parent)
        self.segments = segments
        
        self.preset_manager = preset_manager
        self.preset_order_manager = preset_order_manager
        self.character_stats = {}  # 存储角色统计信息
        self.nickname_candidates = {}  # 存储小名候选
        self.surname_contexts = {}  # 存储姓氏上下文
        self.character_preset_mapping = {}  # 存储角色-预设映射
        self.preset_history = {}  # 存储预设的历史记录
        self.configured_characters = {}  # 存储已完成配置的角色信息
        self.characters = []  # 存储所有检测到的角色列表
        
        # 从预设管理器加载历史预设信息
        self.load_preset_history()
        
        # 保存过滤英文后的全文
        self.filtered_text = "\n".join(segments)
        
        self.init_ui()
        self.analyze_text()

    def init_ui(self):
        # 计算基础字体大小和控件高度
        parent_window = self.window()
        if parent_window:
            base_font_size = max(12, int(parent_window.width() / 72))
            control_height = int(parent_window.height() * 0.04)
        else:
            base_font_size = 12
            control_height = 30

        layout = QVBoxLayout(self)
        layout.setSpacing(20)
        
        # 顶部导航
        nav_layout = QHBoxLayout()
        back_btn = QPushButton("返回")
        back_btn.clicked.connect(self.go_back)
        back_btn.setMinimumHeight(control_height)
        back_btn.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        nav_layout.addWidget(back_btn)
        nav_layout.addStretch()
        
        # 角色统计区域
        character_group = QGroupBox("角色统计")
        character_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(control_height * 0.5)}px;
                margin-top: {int(control_height * 0.35)}px;
            }}
        """)
        character_layout = QVBoxLayout(character_group)
        
        # 角色列表
        self.character_table = QTableWidget()
        self.character_table.setColumnCount(5)
        self.character_table.setHorizontalHeaderLabels(["角色名称", "出现次数", "配音预设", "是否处理", "配置完成"])
        self.character_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.character_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.character_table.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)
        self.character_table.itemSelectionChanged.connect(self.on_character_selected)
        # 🔧 设置合适的行高（40px）与其他表格保持一致
        self.character_table.verticalHeader().setDefaultSectionSize(40)
        # 设置表格高度以显示约10行内容
        self.character_table.setMinimumHeight(int(control_height * 10))
        self.character_table.setStyleSheet(f"""
            QTableWidget {{
                font-size: {int(base_font_size * 0.9)}px;
            }}
            QHeaderView::section {{
                font-size: {int(base_font_size * 0.9)}px;
                padding: 4px;
            }}
        """)
        character_layout.addWidget(self.character_table)
        
        # 角色处理区域
        process_group = QGroupBox("角色处理")
        process_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(control_height * 0.5)}px;
                margin-top: {int(control_height * 0.35)}px;
            }}
        """)
        process_layout = QVBoxLayout(process_group)
        
        # 当前处理的角色信息
        current_char_layout = QGridLayout()
        
        # 角色名称
        self.current_char_label = QLabel("当前角色：")
        self.current_char_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.current_char_name = QLabel("")
        self.current_char_name.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        current_char_layout.addWidget(self.current_char_label, 0, 0)
        current_char_layout.addWidget(self.current_char_name, 0, 1)
        
        # 预设信息输入区域
        self.preset_info_group = QGroupBox("预设信息")
        self.preset_info_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(control_height * 0.5)}px;
                margin-top: {int(control_height * 0.35)}px;
            }}
        """)
        preset_info_layout = QGridLayout(self.preset_info_group)
        
        # 姓氏输入
        surname_label = QLabel("姓氏：")
        surname_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.surname_input = QLineEdit()
        self.surname_input.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.surname_input.setMinimumHeight(control_height)
        preset_info_layout.addWidget(surname_label, 0, 0)
        preset_info_layout.addWidget(self.surname_input, 0, 1)
        
        # 姓名输入
        name_label = QLabel("姓名：")
        name_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.name_input = QLineEdit()
        self.name_input.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.name_input.setMinimumHeight(control_height)
        preset_info_layout.addWidget(name_label, 1, 0)
        preset_info_layout.addWidget(self.name_input, 1, 1)
        
        # 小名输入
        nickname_label = QLabel("小名：")
        nickname_label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.nickname_input = QLineEdit()
        self.nickname_input.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.nickname_input.setMinimumHeight(control_height)
        preset_info_layout.addWidget(nickname_label, 2, 0)
        preset_info_layout.addWidget(self.nickname_input, 2, 1)
        
        # 添加一键填入角色按钮
        self.auto_fill_btn = QPushButton("一键填入角色")
        self.auto_fill_btn.setStyleSheet(f"""
            QPushButton {{
                font-size: {int(base_font_size * 0.9)}px;
                background-color: #E8F4F8;
                border: 1px solid #B8D4E3;
                border-radius: 4px;
                padding: 4px;
            }}
            QPushButton:hover {{
                background-color: #D0E8F2;
            }}
        """)
        self.auto_fill_btn.setMinimumHeight(control_height)
        self.auto_fill_btn.clicked.connect(self.auto_fill_character_info)
        preset_info_layout.addWidget(self.auto_fill_btn, 3, 0, 1, 2)
        
        # 添加保存按钮
        self.save_preset_btn = QPushButton("保存预设信息")
        self.save_preset_btn.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        self.save_preset_btn.setMinimumHeight(control_height)
        self.save_preset_btn.clicked.connect(self.save_preset_info)
        preset_info_layout.addWidget(self.save_preset_btn, 4, 0, 1, 2)
        
        # 添加预设信息组到处理区域
        process_layout.addLayout(current_char_layout)
        process_layout.addWidget(self.preset_info_group)
        
        # 小名识别区域
        nickname_group = QGroupBox("小名识别")
        nickname_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(control_height * 0.5)}px;
                margin-top: {int(control_height * 0.35)}px;
            }}
        """)
        nickname_layout = QVBoxLayout(nickname_group)
        self.nickname_table = QTableWidget()
        self.nickname_table.setColumnCount(3)
        self.nickname_table.setHorizontalHeaderLabels(["可能的小名", "出现次数", "是否使用"])
        self.nickname_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        # 🔧 设置合适的行高（40px）
        self.nickname_table.verticalHeader().setDefaultSectionSize(40)
        # 设置表格高度以显示约10行内容
        self.nickname_table.setMinimumHeight(int(control_height * 10))
        self.nickname_table.setStyleSheet(f"""
            QTableWidget {{
                font-size: {int(base_font_size * 0.9)}px;
            }}
            QHeaderView::section {{
                font-size: {int(base_font_size * 0.9)}px;
                padding: 4px;
            }}
        """)
        nickname_layout.addWidget(self.nickname_table)
        
        # 姓氏处理区域
        surname_group = QGroupBox("姓氏处理")
        surname_group.setStyleSheet(f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(control_height * 0.5)}px;
                margin-top: {int(control_height * 0.35)}px;
            }}
        """)
        surname_layout = QVBoxLayout(surname_group)
        self.surname_table = QTableWidget()
        self.surname_table.setColumnCount(4)
        self.surname_table.setHorizontalHeaderLabels(["包含姓氏的词", "出现次数", "上下文示例", "是否替换"])
        self.surname_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        # 🔧 设置合适的行高（40px）
        self.surname_table.verticalHeader().setDefaultSectionSize(40)
        # 设置表格高度以显示约10行内容
        self.surname_table.setMinimumHeight(int(control_height * 10))
        self.surname_table.setStyleSheet(f"""
            QTableWidget {{
                font-size: {int(base_font_size * 0.9)}px;
            }}
            QHeaderView::section {{
                font-size: {int(base_font_size * 0.9)}px;
                padding: 4px;
            }}
        """)
        surname_layout.addWidget(self.surname_table)
        
        # 开始处理按钮
        button_layout = QHBoxLayout()
        self.process_btn = QPushButton("开始处理")
        self.process_btn.setObjectName("generate_btn")
        self.process_btn.clicked.connect(self.process_characters)
        self.process_btn.setMinimumHeight(int(control_height * 1.25))
        self.process_btn.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        button_layout.addStretch()
        button_layout.addWidget(self.process_btn)
        
        # 添加所有组件到主布局
        layout.addLayout(nav_layout)
        layout.addWidget(character_group)
        layout.addWidget(process_group)
        layout.addWidget(nickname_group)
        layout.addWidget(surname_group)
        layout.addLayout(button_layout)
        
        # 初始时隐藏预设信息输入区域
        self.preset_info_group.hide()
        
        # 添加窗口大小变化事件处理
        self.resizeEvent = self.on_resize

    def on_resize(self, event):
        """处理窗口大小变化事件"""
        # 更新基础字体大小和控件高度
        parent_window = self.window()
        if parent_window:
            base_font_size = max(12, int(parent_window.width() / 72))
            control_height = int(parent_window.height() * 0.04)
        else:
            base_font_size = 12
            control_height = 30
        
        # 更新所有标签的字体大小
        for label in self.findChildren(QLabel):
            label.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        
        # 更新所有输入框的字体大小和高度
        for widget in self.findChildren(QLineEdit):
            widget.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
            widget.setMinimumHeight(control_height)
        
        # 更新所有按钮的字体大小和高度
        for button in self.findChildren(QPushButton):
            if button.objectName() == "generate_btn":
                button.setMinimumHeight(int(control_height * 1.25))
            else:
                button.setMinimumHeight(control_height)
            button.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        
        # 更新所有表格的字体大小
        table_style = f"""
            QTableWidget {{
                font-size: {int(base_font_size * 0.9)}px;
            }}
            QHeaderView::section {{
                font-size: {int(base_font_size * 0.9)}px;
                padding: 4px;
            }}
        """
        self.character_table.setStyleSheet(table_style)
        self.nickname_table.setStyleSheet(table_style)
        self.surname_table.setStyleSheet(table_style)
        
        # 更新所有组框的样式
        group_style = f"""
            QGroupBox {{
                font-size: {int(base_font_size * 1.1)}px;
                font-weight: 500;
                padding-top: {int(control_height * 0.5)}px;
                margin-top: {int(control_height * 0.35)}px;
            }}
        """
        for group in self.findChildren(QGroupBox):
            group.setStyleSheet(group_style)
        
        # 🔧 更新所有下拉框的样式 - 保持与全局样式一致
        for combo in self.findChildren(QComboBox):
            combo.setStyleSheet(f"""
                                 QComboBox {{
                     background-color: #faf6f1 !important;
                     border: 1px solid #d4c5b9 !important;
                     border-radius: 6px !important;
                     padding-left: 8px !important;
                     padding-right: 8px !important;
                     padding-top: 1px !important;    /* 最小化垂直内边距 */
                     padding-bottom: 1px !important; /* 最小化垂直内边距 */
                     height: 18px !important;
                     max-height: 18px !important;
                     min-height: 18px !important;
                     color: #4a5568 !important;
                     font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif !important;
                     font-size: {int(base_font_size * 0.9)}px !important;
                     text-align: left !important;
                     line-height: 20px !important;
                 }}
                QComboBox:hover {{
                    background-color: #f7f3ee !important;
                    border-color: #C67A8A !important;
                }}
                QComboBox:focus {{
                    border-color: #C67A8A !important;
                    outline: none !important;
                }}
                                 QComboBox::drop-down {{
                     border: none !important;
                     background: transparent !important;
                     width: 0px !important;  /* 完全隐藏下拉按钮区域 */
                 }}
                 QComboBox::down-arrow {{
                     image: none !important;
                     border: none !important;
                     background: transparent !important;
                     width: 0 !important;
                     height: 0 !important;
                 }}
            """)
        
        # 更新所有复选框的字体大小
        for checkbox in self.findChildren(QCheckBox):
            checkbox.setStyleSheet(f"font-size: {int(base_font_size * 0.9)}px;")
        
        super().resizeEvent(event)

    def update_character_table(self):
        """更新角色表格"""
        try:
            # 清空表格
            self.character_table.clearContents()
            self.character_table.setRowCount(0)
            
            # 添加角色到表格
            for i, character in enumerate(self.characters):
    
                self.character_table.insertRow(i)
                
                # 角色名称
                item = QTableWidgetItem(character)
                item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)  # 设置为只读
                self.character_table.setItem(i, 0, item)
                
                # 角色频率
                freq_item = QTableWidgetItem(f"{self.char_stats[character]}")
                freq_item.setFlags(freq_item.flags() & ~Qt.ItemFlag.ItemIsEditable)  # 设置为只读
                self.character_table.setItem(i, 1, freq_item)
                
                                # 🔧 预设选择 - 使用居中容器
                preset_combo = QComboBox()
                
                # 从预设管理器获取所有预设
                all_presets = [preset[0] for preset in self.preset_manager.get_all_presets()]
        
                # 🔧 使用预设排序管理器进行排序
                if self.preset_order_manager:
                    sorted_presets = self.preset_order_manager.sort_presets(all_presets)
                else:
                    sorted_presets = all_presets
                
                # 先添加排序后的预设列表
                for preset_name in sorted_presets:
                    preset_combo.addItem(preset_name)
                
                # 同时也加载历史预设记录
                for preset_name in self.preset_history.keys():
                    if preset_name not in all_presets:
                        preset_combo.addItem(preset_name)
                        
                # 设置默认选择（如果卡芙卡在列表中则选择它，否则选择第一个）
                default_index = preset_combo.findText("🔮卡芙卡")
                if default_index == -1:  # 如果没找到卡芙卡，尝试查找其他版本
                    default_index = preset_combo.findText("卡芙卡")
                if default_index >= 0:
                    preset_combo.setCurrentIndex(default_index)
                elif preset_combo.count() > 0:
                    preset_combo.setCurrentIndex(0)  # 选择第一个预设
                        
                # 如果角色已有配置，选择对应的预设
                if character in self.configured_characters:
                    preset_name = self.configured_characters[character]["preset_name"]
                    index = preset_combo.findText(preset_name)
                    if index >= 0:
                        preset_combo.setCurrentIndex(index)

                # 🔧 为下拉框创建居中容器 - 调整垂直对齐
                preset_widget = QWidget()
                preset_widget.setObjectName("cell-widget-container")  # 设置对象名用于样式
                preset_layout = QHBoxLayout(preset_widget)
                preset_layout.addWidget(preset_combo)
                preset_layout.setContentsMargins(4, 0, 4, 10)  # 调整边距适应40px行高
                preset_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
                preset_widget.setMaximumHeight(40)  # 限制容器高度与表格行高一致
                    
                self.character_table.setCellWidget(i, 2, preset_widget)
                preset_combo.currentIndexChanged.connect(lambda idx, row=i: self.on_preset_selected(row, idx))
                
                # 🔧 是否处理复选框 - 使用居中容器
                process_check = QCheckBox()
                process_check.setChecked(False)  # 默认不勾选
                
                process_widget = QWidget()
                process_widget.setObjectName("cell-widget-container")  # 设置对象名用于样式
                process_layout = QHBoxLayout(process_widget)
                process_layout.addWidget(process_check)
                process_layout.setContentsMargins(8, 4, 8, 4)
                process_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
                
                self.character_table.setCellWidget(i, 3, process_widget)
                
                # 🔧 配置完成复选框 - 使用居中容器
                config_check = QCheckBox()
                # 如果角色已有配置，勾选配置完成
                is_configured = character in self.configured_characters
                config_check.setChecked(is_configured)
                
                config_widget = QWidget()
                config_widget.setObjectName("cell-widget-container")  # 设置对象名用于样式
                config_layout = QHBoxLayout(config_widget)
                config_layout.addWidget(config_check)
                config_layout.setContentsMargins(8, 4, 8, 4)
                config_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
                
                self.character_table.setCellWidget(i, 4, config_widget)
                
                # 关联信号 - 使用角色名称而非行索引作为标识符
                config_check.stateChanged.connect(lambda state, char=character: self.on_config_completed(char, state))
                
            
            # 调整列宽
            self.character_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
            self.character_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
            self.character_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
            self.character_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
            self.character_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
            
            # 如果表格有数据，默认选中第一行
            if self.character_table.rowCount() > 0:
                self.character_table.selectRow(0)
                
        except Exception as e:
            QMessageBox.critical(self, "错误", f"更新角色表格时出错：{str(e)}")

    def on_preset_selected(self, row: int, preset_index: int):
        """当选择预设时的处理"""
        character = self.character_table.item(row, 0).text()
        # 🔧 从容器中获取下拉框
        preset_widget = self.character_table.cellWidget(row, 2)
        preset_combo = preset_widget.layout().itemAt(0).widget()
        preset_name = preset_combo.currentText()
        
        # 更新角色-预设映射
        self.character_preset_mapping[character] = preset_name
        
        # 如果当前选中的是这一行，更新预设信息显示
        if self.character_table.currentRow() == row:
            # 保存当前预设信息（如果有）
            current_widget = self.character_table.cellWidget(self.character_table.currentRow(), 2)
            current_combo = current_widget.layout().itemAt(0).widget()
            current_preset = current_combo.currentText()
            if current_preset != "卡芙卡" and current_preset != preset_name:
                # 只有当输入框不为空时才保存
                if any([self.surname_input.text().strip(), 
                       self.name_input.text().strip(), 
                       self.nickname_input.text().strip()]):
                    self.preset_history[current_preset] = {
                        "surname": self.surname_input.text().strip(),
                        "name": self.name_input.text().strip(),
                        "nickname": self.nickname_input.text().strip()
                    }
            
            # 更新显示新预设的信息
            self.update_preset_info_display(preset_name)

    def update_preset_info_display(self, preset_name: str):
        """更新预设信息显示"""
        # 如果是默认预设，隐藏输入框并清空
        if preset_name == "卡芙卡":
            self.preset_info_group.hide()
            self.surname_input.clear()
            self.name_input.clear()
            self.nickname_input.clear()
            return
            
        # 显示预设信息输入区域
        self.preset_info_group.show()
            
        # 从预设管理器获取预设信息
        preset_info = self.preset_manager.get_preset(preset_name)
        if preset_info and preset_info[0].get('character_info'):
            character_info = preset_info[0]['character_info']
            self.surname_input.setText(character_info.get('surname', ''))
            self.name_input.setText(character_info.get('name', ''))
            self.nickname_input.setText(character_info.get('nickname', ''))
        else:
            # 如果预设中没有保存的信息，清空输入框
            self.surname_input.clear()
            self.name_input.clear()
            self.nickname_input.clear()

    def process_characters(self):
        """处理角色替换并生成最终文本"""
        try:
            # 获取需要处理的角色
            characters_to_process = []
            unconfigured_characters = []
            
            for i in range(self.character_table.rowCount()):
                char = self.character_table.item(i, 0).text()
                process_widget = self.character_table.cellWidget(i, 3)
                
                # 🔧 从容器中获取复选框
                process_check = process_widget.layout().itemAt(0).widget()
                
                # 检查是否勾选了"是否处理"
                if process_check.isChecked():
                    # 检查是否已配置完成
                    if char in self.configured_characters:
                        # 使用已保存的配置
                        characters_to_process.append((char, self.configured_characters[char]["preset_name"]))
                    else:
                        # 记录未配置的角色
                        unconfigured_characters.append(char)
            
            # 如果有未配置的角色，提示用户
            if unconfigured_characters:
                error_message = "以下角色被勾选处理但未完成配置：\n" + "\n".join(unconfigured_characters)
                QMessageBox.warning(self, "未完成配置", error_message)
                return
            
            if not characters_to_process:
                # 不再强制要求选择角色，直接使用原始文本
                processed_text = self.filtered_text
                
                # 尝试从MainWindow获取当前处理的文件名
                main_window = self.window()
                source_filename = "unknown"
                
                if hasattr(main_window, 'current_file') and main_window.current_file:
                    # 从MainWindow获取当前文件路径
                    source_filename = os.path.splitext(os.path.basename(main_window.current_file))[0]
                
                # 保存处理后的文本到Working目录
                working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
                processed_dir = os.path.join(working_dir, f"{source_filename}_processed")
                os.makedirs(processed_dir, exist_ok=True)
                
                # 获取主页面设置的分段字数
                parent = self.window()
                if isinstance(parent, MainWindow):
                    batch_size = parent.batch_spin.value()
                else:
                    batch_size = 5000  # 默认值
                
                # 按字数分段
                processed_segments = []
                current_text = processed_text
                while current_text:
                    # 找到合适的分段点
                    if len(current_text) <= batch_size:
                        processed_segments.append(current_text)
                        break
                        
                    # 计算当前批次的理想结束位置
                    ideal_end = min(batch_size, len(current_text))
                    
                    # 首先在理想位置附近查找中文句号'。'和中文右引号'\u201d'组合
                    best_break_pos = ideal_end - 1  # 默认为批次大小位置
                    
                    # 向后查找最近的合适断点
                    for i in range(ideal_end - 1, 0, -1):
                        if i + 1 < len(current_text) and current_text[i] == '。' and current_text[i + 1] == '\u201d':
                            best_break_pos = i + 1  # 包含中文句号和右引号
                            break
                    
                    # 如果没找到中文句号和右引号组合，则尝试只查找中文句号
                    if best_break_pos == ideal_end - 1:
                        for i in range(ideal_end - 1, 0, -1):
                            if current_text[i] == '。':
                                best_break_pos = i  # 包含中文句号
                                break
                    
                    # 获取分段（包含断点字符）
                    processed_segments.append(current_text[:best_break_pos + 1])
                    current_text = current_text[best_break_pos + 1:]
                
                # 保存分段文本
                segments_file = os.path.join(processed_dir, "segments.txt")
                with open(segments_file, 'w', encoding='utf-8') as f:
                    for i, segment in enumerate(processed_segments, 1):
                        f.write(f"[段落 {i}]\n{segment}\n\n")
                
                QMessageBox.information(self, "成功", f"文本处理完成！\n未选择角色，将使用原始文本。\n输出目录：{processed_dir}")
                
                # 进入分段处理页面 - 使用空角色列表
                parent = self.window()
                if isinstance(parent, MainWindow):
                    parent.show_segment_process_page(processed_segments, [])
                return
            
            # 输出调试信息
            
            
            # 创建进度条
            progress = QProgressDialog("正在处理文本...", "取消", 0, len(characters_to_process), self)
            progress.setWindowTitle("处理中")
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setMinimumWidth(300)
            progress.show()
            
            # 创建处理后的文本副本
            processed_text = self.filtered_text
            
            # 创建替换映射表
            name_replacements = {}        # 角色名替换映射
            surname_replacements = {}     # 姓氏词替换映射
            nickname_replacements = {}    # 小名替换映射
            
            # 从已配置的角色信息中收集所有替换内容
            for idx, (character, preset_name) in enumerate(characters_to_process):
                if progress.wasCanceled():
                    return
                    
                progress.setValue(idx)
                progress.setLabelText(f"处理角色：{character}")
                
                # 从已保存的配置中获取替换信息
                char_config = self.configured_characters[character]
                
                # 1. 记录角色名替换
                name_replacements[character] = char_config["new_name"]
                
                # 2. 记录姓氏相关词替换
                for old_word, new_word in char_config["surname_replacements"].items():
                    surname_replacements[old_word] = (new_word, character)
                
                # 3. 记录小名替换
                for old_nickname, new_nickname in char_config["nickname_replacements"].items():
                    nickname_replacements[old_nickname] = new_nickname
            
            # 调试输出
            
            
            # 第二阶段：按照优先级顺序进行替换
            # 1. 先替换角色名（从最长到最短，避免部分匹配问题）
            progress.setLabelText(f"替换角色名...")
            sorted_characters = sorted(name_replacements.keys(), key=len, reverse=True)
            for char in sorted_characters:
                processed_text = processed_text.replace(char, name_replacements[char])
                
            # 2. 再替换姓氏相关词（按照长度排序）
            progress.setLabelText(f"替换姓氏相关词...")
            sorted_surnames = sorted(surname_replacements.keys(), key=len, reverse=True)
            for surname in sorted_surnames:
                new_surname, _ = surname_replacements[surname]
                processed_text = processed_text.replace(surname, new_surname)
                
            # 3. 最后替换小名（按照长度排序）
            progress.setLabelText(f"替换小名...")
            sorted_nicknames = sorted(nickname_replacements.keys(), key=len, reverse=True)
            for nickname in sorted_nicknames:
                processed_text = processed_text.replace(nickname, nickname_replacements[nickname])
            
            progress.setValue(len(characters_to_process))
            
            # 尝试从MainWindow获取当前处理的文件名
            main_window = self.window()
            source_filename = "unknown"
            
            if hasattr(main_window, 'current_file') and main_window.current_file:
                # 从MainWindow获取当前文件路径
                source_filename = os.path.splitext(os.path.basename(main_window.current_file))[0]
            
            # 保存处理后的文本到Working目录
            working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
            processed_dir = os.path.join(working_dir, f"{source_filename}_processed")
            os.makedirs(processed_dir, exist_ok=True)
            
            # 获取主页面设置的分段字数
            parent = self.window()
            if isinstance(parent, MainWindow):
                batch_size = parent.batch_spin.value()
            else:
                batch_size = 5000  # 默认值
            
            # 按字数分段
            processed_segments = []
            current_text = processed_text
            while current_text:
                # 找到合适的分段点
                if len(current_text) <= batch_size:
                    processed_segments.append(current_text)
                    break
                        
                # 计算当前批次的理想结束位置
                ideal_end = min(batch_size, len(current_text))
                
                # 首先在理想位置附近查找中文句号'。'和中文右引号'\u201d'组合
                best_break_pos = ideal_end - 1  # 默认为批次大小位置
                
                # 向后查找最近的合适断点
                for i in range(ideal_end - 1, 0, -1):
                    if i + 1 < len(current_text) and current_text[i] == '。' and current_text[i + 1] == '\u201d':
                        best_break_pos = i + 1  # 包含中文句号和右引号
                        break
                
                # 如果没找到中文句号和右引号组合，则尝试只查找中文句号
                if best_break_pos == ideal_end - 1:
                    for i in range(ideal_end - 1, 0, -1):
                        if current_text[i] == '。':
                            best_break_pos = i  # 包含中文句号
                            break
                
                # 获取分段（包含断点字符）
                processed_segments.append(current_text[:best_break_pos + 1])
                current_text = current_text[best_break_pos + 1:]
            
            # 保存分段文本
            segments_file = os.path.join(processed_dir, "segments.txt")
            with open(segments_file, 'w', encoding='utf-8') as f:
                for i, segment in enumerate(processed_segments, 1):
                    f.write(f"[段落 {i}]\n{segment}\n\n")
            
            QMessageBox.information(self, "成功", f"文本处理完成！\n输出目录：{processed_dir}")
            
            # 进入分段处理页面
            parent = self.window()
            if isinstance(parent, MainWindow):
                parent.show_segment_process_page(processed_segments, characters_to_process)
            
        except Exception as e:
            QMessageBox.critical(self, "错误", f"处理角色时出错：{str(e)}")

    def on_character_selected(self):
        """当选择角色时的处理"""
        selected_items = self.character_table.selectedItems()
        if not selected_items:
            return
            
        row = selected_items[0].row()
        character = self.character_table.item(row, 0).text()
        self.current_char_name.setText(character)
        
        # 🔧 获取当前选中的预设 - 从容器中获取下拉框
        preset_widget = self.character_table.cellWidget(row, 2)
        preset_combo = preset_widget.layout().itemAt(0).widget()
        preset_name = preset_combo.currentText()
        
        # 更新预设信息显示
        self.update_preset_info_display(preset_name)
        
        # 分析该角色的小名和姓氏
        self.analyze_nicknames(character)
        
        # 获取预设信息
        preset_info = None
        if preset_name:
            preset_data = self.preset_manager.get_preset(preset_name)
            if preset_data and preset_data[0].get('character_info'):
                preset_info = preset_data[0]['character_info']
        
        # 使用预设中的姓氏（如果有），否则默认使用角色名的第一个字符
        char_surname = ""
        if len(character) >= 1:
            char_surname = character[0]  # 第一个字作为姓氏

        
        if char_surname:
            self.analyze_surname_contexts(char_surname)

    def analyze_text(self):
        """分析文本，统计2-4字词的出现频率，并检测可能的完整人名"""
        # 使用过滤后的全文
        full_text = self.filtered_text
        
        # 使用jieba分词
        words = jieba.lcut(full_text)
        
        # 统计2-4字词的频率
        word_stats = {}
        
        # 先处理普通分词结果
        for word in words:
            # 只统计2-4字的词
            if 2 <= len(word) <= 4:
                # 检查词是否只包含中文字符
                if all('\u4e00' <= char <= '\u9fff' for char in word):
                    word_stats[word] = word_stats.get(word, 0) + 1
        
        # 寻找可能的完整人名（连续出现的词组合）
        for i in range(len(words) - 1):
            # 检查相邻的两个词是否都是中文且长度合适
            if (1 <= len(words[i]) <= 2 and 1 <= len(words[i+1]) <= 2 and
                all('\u4e00' <= char <= '\u9fff' for char in words[i]) and
                all('\u4e00' <= char <= '\u9fff' for char in words[i+1])):
                # 组合相邻的两个词，例如"八重"+"神子"="八重神子"
                combined_name = words[i] + words[i+1]
                # 只处理2-4字的组合名
                if 2 <= len(combined_name) <= 4:
                    # 在原文中搜索这个组合名出现的次数
                    count = full_text.count(combined_name)
                    if count > 0:
                        word_stats[combined_name] = count
        
        # 按出现频率排序，取前1000位
        sorted_words = sorted(word_stats.items(), key=lambda x: x[1], reverse=True)[:1000]
        self.character_stats = dict(sorted_words)
        
        # 提取检测到的所有角色名
        self.characters = list(self.character_stats.keys())

        
        # 同时初始化角色的统计数据
        self.char_stats = self.character_stats
        
        # 更新角色列表显示
        self.update_character_table()
        
        # 如果有角色，默认选择第一个
        if self.character_table.rowCount() > 0:
            self.character_table.selectRow(0)
            self.on_character_selected()

    def analyze_nicknames(self, character: str):
        """分析角色可能的小名，统计：
        1. 二字叠词（如"霄霄"）
        2. 两字词中包含角色名其中一个字（不考虑姓氏）
        3. 角色除姓氏外的完整名字（如"王英华"中的"英华"）
        4. "小"字加完整名字中的其中一个字（如"小华"）
        """
        # 清空当前角色的小名候选列表，而不是清空所有候选
        if character in self.nickname_candidates:
            self.nickname_candidates[character] = {}
        else:
            self.nickname_candidates[character] = {}
        
        # 在文本中查找可能的小名
        full_text = self.filtered_text
        
        # 使用jieba分词
        words = jieba.lcut(full_text)
        
        # 提取角色姓氏和名字部分
        surname = ""
        name_part = ""
        if len(character) >= 2:
            surname = character[0]  # 假设第一个字是姓
            name_part = character[1:]  # 除姓氏外的部分
        
        # 查找符合条件的小名
        for word in words:
            should_add = False
            
            # 1. 处理二字叠词
            if len(word) == 2 and word[0] == word[1]:
                should_add = True
                
            # 2. 检查两字词中是否包含角色名其中一个字（不考虑姓氏）
            elif len(word) == 2:
                chars_in_name = sum(1 for c in word if c in character[1:])
                if chars_in_name == 1:  # 只包含名字中的一个字
                    should_add = True
            
            # 3. 检查是否是角色除姓氏外的完整名字
            if len(name_part) >= 2 and word == name_part:
                should_add = True
                
            # 4. 检查是否是"小"字加角色名中的一个字
            if len(word) == 2 and word[0] == "小" and word[1] in character:
                should_add = True
            
            if should_add:
                if word in self.nickname_candidates[character]:
                    self.nickname_candidates[character][word] += 1
                else:
                    self.nickname_candidates[character][word] = 1
        
        # 更新小名表格
        self.update_nickname_table()
    
    def update_nickname_table(self):
        """更新小名表格"""
        # 获取当前选中的角色
        selected_items = self.character_table.selectedItems()
        if not selected_items:
            return
            
        row = selected_items[0].row()
        character = self.character_table.item(row, 0).text()
        
        # 如果角色没有小名候选列表，则清空表格
        if character not in self.nickname_candidates:
            self.nickname_table.setRowCount(0)
            return
            
        # 按出现频率排序
        sorted_nicknames = sorted(self.nickname_candidates[character].items(), key=lambda x: x[1], reverse=True)
        
        # 设置表格行数
        self.nickname_table.setRowCount(len(sorted_nicknames))
        
        # 填充数据
        for i, (nickname, count) in enumerate(sorted_nicknames):
            # 小名
            name_item = QTableWidgetItem(nickname)
            name_item.setFlags(name_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            self.nickname_table.setItem(i, 0, name_item)
            
            # 出现次数
            count_item = QTableWidgetItem(str(count))
            count_item.setFlags(count_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            self.nickname_table.setItem(i, 1, count_item)
            
            # 🔧 使用复选框 - 使用居中容器
            use_check = QCheckBox()
            
            use_widget = QWidget()
            use_widget.setObjectName("cell-widget-container")  # 设置对象名用于样式
            use_layout = QHBoxLayout(use_widget)
            use_layout.addWidget(use_check)
            use_layout.setContentsMargins(8, 4, 8, 4)
            use_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            
            self.nickname_table.setCellWidget(i, 2, use_widget)
    
    def analyze_surname_contexts(self, surname: str):
        """分析姓氏相关的词，直接查找姓氏后跟随的字符，组成二字词"""

        self.surname_contexts = {}  # 清空现有内容，改为字典结构{词: (频率, 上下文)}
        
        # 直接在文本中查找姓氏后跟随的字符
        full_text = self.filtered_text
        
        # 遍历文本，查找姓氏出现的位置
        for i in range(len(full_text) - 1):
            # 找到姓氏
            if full_text[i] == surname:
                # 获取姓氏后面的一个字符
                next_char = full_text[i + 1]
                # 检查是否是中文字符
                if '\u4e00' <= next_char <= '\u9fff':
                    # 组成二字词
                    two_char_word = surname + next_char
                    
                    # 获取上下文（前后五个字）
                    context_start = max(0, i - 5)
                    context_end = min(len(full_text), i + 7)  # 二字词加前后共五个字
                    context = full_text[context_start:context_end]
                    
                    # 统计频率和保存上下文
                    if two_char_word in self.surname_contexts:
                        count, _ = self.surname_contexts[two_char_word]
                        self.surname_contexts[two_char_word] = (count + 1, context)
                    else:
                        self.surname_contexts[two_char_word] = (1, context)
        
        # 更新姓氏表格
        self.update_surname_table()
    
    def update_surname_table(self):
        """更新姓氏表格"""
        # 按出现频率排序
        sorted_contexts = sorted(self.surname_contexts.items(), key=lambda x: x[1][0], reverse=True)
        
        # 设置表格列数
        self.surname_table.setColumnCount(4)
        self.surname_table.setHorizontalHeaderLabels(["包含姓氏的词", "出现次数", "上下文示例", "是否替换"])
        
        # 设置表格行数
        self.surname_table.setRowCount(len(sorted_contexts))
        
        # 填充数据
        for i, (context_word, (count, context_example)) in enumerate(sorted_contexts):
            # 包含姓氏的词
            context_item = QTableWidgetItem(context_word)
            context_item.setFlags(context_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            self.surname_table.setItem(i, 0, context_item)
            
            # 出现次数
            count_item = QTableWidgetItem(str(count))
            count_item.setFlags(count_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            self.surname_table.setItem(i, 1, count_item)
            
            # 上下文示例
            context_example_item = QTableWidgetItem(context_example)
            context_example_item.setFlags(context_example_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            self.surname_table.setItem(i, 2, context_example_item)
            
            # 🔧 替换复选框，默认选中 - 使用居中容器
            replace_check = QCheckBox()
            replace_check.setChecked(True)  # 默认选中
            
            replace_widget = QWidget()
            replace_widget.setObjectName("cell-widget-container")  # 设置对象名用于样式
            replace_layout = QHBoxLayout(replace_widget)
            replace_layout.addWidget(replace_check)
            replace_layout.setContentsMargins(8, 4, 8, 4)
            replace_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            
            self.surname_table.setCellWidget(i, 3, replace_widget)
            
        # 调整列宽
        self.surname_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.surname_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.surname_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        self.surname_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
    
    def go_back(self):
        """返回主页面"""
        reply = QMessageBox.question(
            self,
            "确认返回",
            "确定要返回主页面吗？已做的角色处理将会丢失。",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            parent = self.window()
            if isinstance(parent, MainWindow):
                parent.show_main_page()

    def load_preset_history(self):
        """从预设管理器加载历史预设信息"""
        try:
            
            self.preset_history = {}
            
            # 从预设管理器获取所有预设
            all_presets = self.preset_manager.get_all_presets()
            
            
            for preset_name, preset_info, _ in all_presets:
                
                # 检查是否有character_info字段
                if 'character_info' in preset_info:
                    
                    self.preset_history[preset_name] = preset_info['character_info']
                else:
                    
                    # 创建默认的character_info
                    character_info = {
                        'surname': preset_name[0] if preset_name else '',
                        'name': preset_name,
                        'nickname': preset_name[:2] if len(preset_name) >= 2 else preset_name
                    }
                    self.preset_history[preset_name] = character_info
                    
                    # 更新预设信息，保存回预设管理器
                    preset_info['character_info'] = character_info
                    settings = preset_info
                    audio_files = [(audio_path, emotion, text) for audio_info in preset_info.get('all_audio_info', []) 
                                  for audio_path, emotion, text in [(audio_info.get('path', ''), 
                                                                   audio_info.get('emotion', ''), 
                                                                   audio_info.get('text', ''))]]
                    self.preset_manager.add_preset(preset_name, settings, audio_files)
        except Exception as e:
            pass

    def save_preset_info(self):
        """保存当前角色的预设信息"""
        current_row = self.character_table.currentRow()
        if current_row < 0:
            QMessageBox.warning(self, "提示", "请先选择一个角色")
            return
            
        # 🔧 获取当前预设名称 - 从容器中获取下拉框
        preset_widget = self.character_table.cellWidget(current_row, 2)
        preset_combo = preset_widget.layout().itemAt(0).widget()
        preset_name = preset_combo.currentText()
        
        if preset_name == "卡芙卡":
            QMessageBox.warning(self, "提示", '默认预设"卡芙卡"无需保存信息')
            return
            
        # 获取输入的预设信息
        surname = self.surname_input.text().strip()
        name = self.name_input.text().strip()
        nickname = self.nickname_input.text().strip()
        
        # 验证输入
        if not all([surname, name, nickname]):
            QMessageBox.warning(self, "提示", "请填写完整的预设信息（姓氏、姓名、小名）")
            return
            
        # 保存预设信息到本地变量
        character_info = {
            "surname": surname,
            "name": name,
            "nickname": nickname
        }
        self.preset_history[preset_name] = character_info
        
        # 获取预设的完整信息并更新
        preset_info = self.preset_manager.get_preset(preset_name)
        if preset_info:
            settings, audio_files = preset_info
            settings['character_info'] = character_info
            # 更新预设
            self.preset_manager.add_preset(preset_name, settings, audio_files)
        
        QMessageBox.information(self, "成功", "预设信息保存成功")

    def auto_fill_character_info(self):
        """一键填入角色信息"""
        current_row = self.character_table.currentRow()
        if current_row < 0:
            QMessageBox.warning(self, "提示", "请先选择一个角色")
            return
            
        # 获取当前角色名称
        character = self.character_table.item(current_row, 0).text()
        
        if not character:
            QMessageBox.warning(self, "提示", "无法获取角色名称")
            return
            
        # 自动填入信息：姓氏=角色名首字，全名=角色名，小名=角色名
        if len(character) >= 1:
            surname = character[0]  # 姓氏为首字
            full_name = character    # 全名为角色名
            nickname = character     # 小名也为角色名
            
            # 填入输入框
            self.surname_input.setText(surname)
            self.name_input.setText(full_name)
            self.nickname_input.setText(nickname)
            
            QMessageBox.information(self, "完成", f"已自动填入角色信息：\n姓氏：{surname}\n全名：{full_name}\n小名：{nickname}\n\n请检查信息是否正确，然后点击保存。")
        else:
            QMessageBox.warning(self, "错误", "角色名称为空，无法自动填入")

    def on_config_completed(self, character, state):
        """处理配置完成状态变化"""
        try:

            
            # 确保将Qt.CheckState转换为布尔值
            is_checked = False
            if isinstance(state, int):
                is_checked = state == 2  # Qt.CheckState.Checked的值是2
            else:
                is_checked = bool(state)
                

            
            if is_checked:  # 如果勾选了配置完成
                success = self.save_character_config(character)
                
                if success:
                    QMessageBox.information(self, "成功", f"已保存角色 {character} 的配置信息")
                
                if not success:  # 如果保存失败，取消勾选
                    # 查找角色所在的行
                    row = -1
                    for i in range(self.character_table.rowCount()):
                        if self.character_table.item(i, 0) and self.character_table.item(i, 0).text() == character:
                            row = i
                            break
                    
                    if row >= 0:
                        config_check = self.character_table.cellWidget(row, 4)
                        if config_check:
                            # 断开信号连接，避免递归调用
                            try:
                                config_check.stateChanged.disconnect()
                            except:
                                pass
                            
                            config_check.setChecked(False)
                            
                            # 重新连接信号
                            config_check.stateChanged.connect(lambda s, c=character: self.on_config_completed(c, s))
            else:  # 如果取消勾选了配置完成
                # 从已配置角色中移除
                if character in self.configured_characters:
                    
                    del self.configured_characters[character]
                    QMessageBox.information(self, "提示", f"已删除角色 {character} 的配置信息")
            

        except Exception as e:
            pass  # 处理配置完成状态变化时出错
    
    def save_character_config(self, character):
        """保存角色配置信息到configured_characters字典中"""
        try:

            
            # 获取当前角色所选的预设
            preset_name = None
            char_row = -1
            
            for i in range(self.character_table.rowCount()):
                if self.character_table.item(i, 0).text() == character:
                    # 🔧 从容器中获取下拉框
                    preset_widget = self.character_table.cellWidget(i, 2)
                    preset_combo = preset_widget.layout().itemAt(0).widget()
                    preset_name = preset_combo.currentText()
                    char_row = i
                    break
            
            if char_row == -1:
                return False
                
            if not preset_name or preset_name == "卡芙卡":
                QMessageBox.warning(self, "提示", f"请为角色 {character} 选择有效的预设")
                # 将配置完成复选框设置为未勾选
                if char_row >= 0:
                    # 🔧 从容器中获取复选框
                    config_widget = self.character_table.cellWidget(char_row, 4)
                    config_check = config_widget.layout().itemAt(0).widget()
                    config_check.setChecked(False)
                return False
            
            if preset_name not in self.preset_history:
                # 从预设管理器中获取预设信息
                preset_info = self.preset_manager.get_preset(preset_name)
                if preset_info and preset_info[0]:
                    # 检查是否有character_info字段
                    if 'character_info' in preset_info[0]:
                        self.preset_history[preset_name] = preset_info[0]['character_info']
                    else:
                        # 尝试提取姓、名、小名信息
                        char_info = {}
                        if 'ref_text' in preset_info[0]:
                            # 简单提取预设名的第一个字作为姓
                            char_info['surname'] = preset_name[0] if preset_name else ''
                            # 使用整个预设名作为名
                            char_info['name'] = preset_name
                            # 小名可以是预设名的前两个字
                            char_info['nickname'] = preset_name[:2] if len(preset_name) >= 2 else preset_name
                            self.preset_history[preset_name] = char_info
                        else:
                            QMessageBox.warning(self, "提示", f"请先为预设 {preset_name} 填写完整的信息")
                            if char_row >= 0:
                                # 🔧 从容器中获取复选框
                                config_widget = self.character_table.cellWidget(char_row, 4)
                                config_check = config_widget.layout().itemAt(0).widget()
                                config_check.setChecked(False)
                            return False
                else:
                    QMessageBox.warning(self, "提示", f"请先为预设 {preset_name} 填写完整的信息")
                    # 将配置完成复选框设置为未勾选
                    if char_row >= 0:
                        # 🔧 从容器中获取复选框
                        config_widget = self.character_table.cellWidget(char_row, 4)
                        config_check = config_widget.layout().itemAt(0).widget()
                        config_check.setChecked(False)
                    return False
            
            # 获取预设信息
            preset_info = self.preset_history[preset_name]
            
            # 必需的预设字段检查
            required_fields = ['surname', 'name', 'nickname']
            missing_fields = [field for field in required_fields if field not in preset_info or not preset_info[field]]
            if missing_fields:
                QMessageBox.warning(self, "提示", f"预设 {preset_name} 缺少必需的信息: {', '.join(missing_fields)}")
                # 将配置完成复选框设置为未勾选
                if char_row >= 0:
                    config_check = self.character_table.cellWidget(char_row, 4)
                    config_check.setChecked(False)
                return False
            
            # 保存当前选中行，以便后面恢复
            current_row = self.character_table.currentRow()
            
            # 选中该角色的行，以便显示其相关信息
            self.character_table.selectRow(char_row)
            
            # 等待事件循环处理选择变更
            QApplication.processEvents()
            
            # 收集姓氏相关词替换
            surname_replacements = {}
            
            # 获取预设信息中的姓氏
            preset_surname = preset_info.get("surname", "")
            
            # 获取当前处理的姓氏（如果使用了analyze_surname_contexts方法，就用那个姓氏）
            current_surname = ""
            
            # 尝试从surname_table中识别当前使用的姓氏
            if self.surname_table.rowCount() > 0:
                first_word = self.surname_table.item(0, 0).text()
                if first_word and len(first_word) > 0:
                    current_surname = first_word[0]  # 姓氏词的第一个字符
            
            # 如果没有找到，则默认使用角色名的第一个字符
            if not current_surname and len(character) > 0:
                current_surname = character[0]
                
            # 确保有预设姓氏
            if not preset_surname:
                pass  # 预设未设置姓氏，不进行姓氏替换
            
            try:
                
                for i in range(self.surname_table.rowCount()):
                    if i >= self.surname_table.rowCount():
                        break
                    
                    try:
                        word_item = self.surname_table.item(i, 0)
                        if not word_item:
                            
                            continue
                            
                        word = word_item.text()
                        replace_check = self.surname_table.cellWidget(i, 3)
                        
                        if not replace_check:
                            
                            continue
                            
                        # 确保这个姓氏词属于当前处理的角色
                        is_checked = replace_check.isChecked()
                        starts_with_surname = word.startswith(current_surname)
                        
                        
                        if is_checked and starts_with_surname and preset_surname and preset_surname != current_surname:
                            # 将以当前姓氏开头的词替换为以预设姓氏开头的词
                            new_word = preset_surname + word[1:]
                            surname_replacements[word] = new_word
                            
                    except Exception as e:
                        pass  # 处理单行错误
            except Exception as e:
                pass  # 收集姓氏相关词替换时出错
                
            # 收集小名替换
            nickname_replacements = {}
            
            try:
                
                for i in range(self.nickname_table.rowCount()):
                    if i >= self.nickname_table.rowCount():
                        break
                        
                    try:
                        nickname_item = self.nickname_table.item(i, 0)
                        if not nickname_item:
                            continue
                            
                        nickname = nickname_item.text()
                        use_check = self.nickname_table.cellWidget(i, 2)
                        
                        if not use_check:
                            continue
                        
                        is_checked = use_check.isChecked()
                        
                        if is_checked:
                            nickname_replacements[nickname] = preset_info["nickname"]
                            
                    except Exception as e:
                        pass  # 处理单行错误
            except Exception as e:
                pass  # 收集小名替换时出错
            
            # 存储配置信息
            self.configured_characters[character] = {
                "preset_name": preset_name,
                "new_name": preset_info["name"],
                "surname_replacements": surname_replacements,
                "nickname_replacements": nickname_replacements
            }
            
            # 恢复原始选中行
            if current_row >= 0:
                self.character_table.selectRow(current_row)
            
            return True
            
        except Exception as e:
            QMessageBox.critical(self, "错误", f"保存角色配置时出错：{str(e)}")
            return False

class SegmentProcessCard(Card):
    def __init__(self, segments: List[str], characters: List[Tuple[str, str]], preset_manager: PresetManager, preset_order_manager: PresetOrderManager = None, parent=None):
        super().__init__(parent)
        self.segments = segments
        self.characters = {char: preset for char, preset in characters}
        self.preset_manager = preset_manager
        self.preset_order_manager = preset_order_manager
        self.current_segment_index = 0
        self.global_narration_preset = "🔮卡芙卡"  # 初始化全局旁白预设为卡芙卡
        self.global_narration_emotion = "平静"  # 初始化全局旁白情绪
        

       
        
        # 从主窗口获取分段大小
        parent_window = self.window()
        if isinstance(parent_window, MainWindow):
            self.batch_size = parent_window.batch_spin.value()
        else:
            self.batch_size = 5000  # 默认值
        
        # 初始化GPT-SoVITS实例
        self.gpt_sovits = GPTSoVITS()
        
        # 初始化其他属性
        self.segment_audio_states = {}  # 存储每个文本框的音频生成状态 {text_edit_id: (is_generated, audio_path)}
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)
        # 设置默认音量
        self.current_volume = 70
        self.audio_output.setVolume(self.current_volume / 100.0)
        
        self.init_ui()
        self.process_current_segment()

    def _is_selector_widget(self, widget):
        """检查widget是否是选择器组件（QComboBox或SwipeSelector）"""
        return isinstance(widget, (QComboBox, SwipeSelector))

    def load_preset_emotion_history(self):
        """从预设管理器加载情绪历史"""
        for preset_name, preset_info, _ in self.preset_manager.get_all_presets():
            if preset_info.get('emotion_history'):
                self.preset_emotion_history[preset_name] = preset_info['emotion_history']
    
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        
        # 导航按钮和功能按钮
        nav_layout = QHBoxLayout()
        self.prev_btn = QPushButton("上一段")
        self.next_btn = QPushButton("下一段")
        self.prev_btn.clicked.connect(self.prev_segment)
        self.next_btn.clicked.connect(self.next_segment)
        nav_layout.addWidget(self.prev_btn)
        self.segment_label = QLabel(f"第 {self.current_segment_index + 1}/{len(self.segments)} 段")
        nav_layout.addWidget(self.segment_label)
        nav_layout.addWidget(self.next_btn)
        
        # 添加预设管理和一键生成按钮
        preset_btn = QPushButton("预设管理")
        preset_btn.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        preset_btn.clicked.connect(self.show_preset_management)
        
        generate_all_btn = QPushButton("一键生成所有")
        generate_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        generate_all_btn.clicked.connect(self.generate_all_audio)
        
        nav_layout.addStretch()
        nav_layout.addWidget(preset_btn)
        nav_layout.addWidget(generate_all_btn)
        
        # 创建滚动区域
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        # 保持水平滚动条始终关闭
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        # 保持垂直滚动条，使其能够滚动查看所有文本框
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #faf6f1;
            }
            QScrollArea > QWidget > QWidget {
                background-color: #faf6f1;
            }
            QScrollBar:vertical {
                border: none;
                background: #f0f0f0;
                width: 10px;
                border-radius: 5px;
            }
            QScrollBar::handle:vertical {
                background: #C67A8A;
                border-radius: 5px;
                min-height: 20px;
            }
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar::add-page:vertical,
            QScrollBar::sub-page:vertical {
                background: none;
            }
        """)
        
        # 创建内容容器
        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setSpacing(10)
        self.content_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        scroll_area.setWidget(self.content_widget)
        
        # 添加组件到主布局
        layout.addLayout(nav_layout)
        layout.addWidget(scroll_area)
        
        # 底部导航按钮 - 添加这个新的部分
        bottom_nav_layout = QHBoxLayout()
        self.bottom_prev_btn = QPushButton("上一段")
        self.bottom_next_btn = QPushButton("下一段")
        self.bottom_prev_btn.clicked.connect(self.prev_segment)
        self.bottom_next_btn.clicked.connect(self.next_segment)
        bottom_nav_layout.addWidget(self.bottom_prev_btn)
        self.bottom_segment_label = QLabel(f"第 {self.current_segment_index + 1}/{len(self.segments)} 段")
        bottom_nav_layout.addWidget(self.bottom_segment_label)
        bottom_nav_layout.addWidget(self.bottom_next_btn)
        bottom_nav_layout.addStretch()
        
        # 添加合并当前段落音频按钮
        merge_audio_btn = QPushButton("合并本段落音频")
        merge_audio_btn.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        merge_audio_btn.clicked.connect(self.merge_segment_audio)
        bottom_nav_layout.addWidget(merge_audio_btn)
        
        # 添加底部一键生成所有按钮
        bottom_generate_all_btn = QPushButton("一键生成所有")
        bottom_generate_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        bottom_generate_all_btn.clicked.connect(self.generate_all_audio)
        bottom_nav_layout.addWidget(bottom_generate_all_btn)
        
        layout.addLayout(bottom_nav_layout)
        
        # 更新导航按钮状态
        self.update_nav_buttons()
    
    def process_current_segment(self):
        """处理当前段落，创建UI组件"""
        # 清空现有内容
        for i in reversed(range(self.content_layout.count())):
            widget = self.content_layout.itemAt(i).widget()
            if widget:
                widget.deleteLater()
        
        # 添加全局替换功能
        replace_frame = QFrame()
        replace_frame.setStyleSheet("""
            QFrame {
                border: 1px solid #d4c5b9;
                border-radius: 8px;
                background-color: #ffffff;
                padding: 10px;
                margin: 5px;
            }
        """)
        replace_layout = QVBoxLayout(replace_frame)
        
        replace_header = QLabel("全局文本替换")
        replace_header.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #C67A8A;
        """)
        replace_layout.addWidget(replace_header)
        
        replace_input_layout = QHBoxLayout()
        search_label = QLabel("查找:")
        search_input = QLineEdit()
        replace_label = QLabel("替换为:")
        replace_input = QLineEdit()
        replace_button = QPushButton("全局替换")
        replace_button.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        
        replace_input_layout.addWidget(search_label)
        replace_input_layout.addWidget(search_input)
        replace_input_layout.addWidget(replace_label)
        replace_input_layout.addWidget(replace_input)
        replace_input_layout.addWidget(replace_button)

        # 添加替换历史下拉框
        history_layout = QHBoxLayout()
        history_label = QLabel("替换历史:")
        history_combo = QComboBox()
        self.update_replace_history_combo(history_combo)
        apply_history_button = QPushButton("应用")
        remove_history_button = QPushButton("删除")
        apply_all_history_button = QPushButton("应用所有历史替换")
        
        apply_history_button.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        
        remove_history_button.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        
        apply_all_history_button.setStyleSheet("""
            QPushButton {
                background-color: #C5D8EC;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B5C8DC;
            }
        """)
        
        history_layout.addWidget(history_label)
        history_layout.addWidget(history_combo)
        history_layout.addWidget(apply_history_button)
        history_layout.addWidget(remove_history_button)
        history_layout.addWidget(apply_all_history_button)
        
        # 全局旁白预设选择
        narration_layout = QHBoxLayout()
        narration_label = QLabel("旁白全局预设:")
        narration_combo = SwipeSelector()
        all_presets = [preset[0] for preset in self.preset_manager.get_all_presets()]
        
        # 🔧 使用预设排序管理器进行排序
        if self.preset_order_manager:
            sorted_presets = self.preset_order_manager.sort_presets(all_presets)
            narration_combo.addItems(sorted_presets)
        else:
            narration_combo.addItems(all_presets)
        
        # 全局旁白情绪选择
        narration_emotion_label = QLabel("旁白情绪:")
        narration_emotion_combo = SwipeSelector()
        # 初始化情绪选择（会在预设改变时更新）
        if all_presets:
            emotions = self.preset_manager.get_preset_emotions(all_presets[0])
            narration_emotion_combo.addItems(emotions)
        
        # 如果之前保存过旁白预设，则设置为上次选择的值
        if hasattr(self, 'global_narration_preset') and self.global_narration_preset in all_presets:
            index = narration_combo.findText(self.global_narration_preset)
            if index >= 0:
                narration_combo.setCurrentIndex(index)
                # 加载对应的情绪选项
                emotions = self.preset_manager.get_preset_emotions(self.global_narration_preset)
                narration_emotion_combo.clear()
                narration_emotion_combo.addItems(emotions)
                # 设置上次选择的情绪
                if hasattr(self, 'global_narration_emotion') and self.global_narration_emotion in emotions:
                    emo_index = narration_emotion_combo.findText(self.global_narration_emotion)
                    if emo_index >= 0:
                        narration_emotion_combo.setCurrentIndex(emo_index)
        
        narration_apply = QPushButton("应用旁白预设")
        narration_apply.setStyleSheet("""
            QPushButton {
                background-color: #C67A8A;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #B56A7A;
            }
        """)
        
        narration_layout.addWidget(narration_label)
        narration_layout.addWidget(narration_combo)
        narration_layout.addWidget(narration_emotion_label)
        narration_layout.addWidget(narration_emotion_combo)
        narration_layout.addWidget(narration_apply)
        narration_layout.addStretch()
        
        replace_layout.addLayout(replace_input_layout)
        replace_layout.addLayout(history_layout)
        replace_layout.addLayout(narration_layout)
        
        # 连接信号
        replace_button.clicked.connect(lambda: self.global_replace(search_input.text(), replace_input.text()))
        narration_combo.currentTextChanged.connect(lambda text: self.on_narration_preset_changed(text, narration_emotion_combo))
        narration_combo.currentTextChanged.connect(self.save_narration_preset)
        narration_emotion_combo.currentTextChanged.connect(self.save_narration_emotion)
        narration_apply.clicked.connect(lambda: self.apply_narration_preset(narration_combo.currentText(), narration_emotion_combo.currentText()))
        
        # 连接替换历史相关信号
        history_combo.currentIndexChanged.connect(lambda: self.on_history_selected(history_combo, search_input, replace_input))
        apply_history_button.clicked.connect(lambda: self.apply_selected_history(history_combo))
        remove_history_button.clicked.connect(lambda: self.remove_selected_history(history_combo))
        apply_all_history_button.clicked.connect(self.apply_all_history)
        
        self.content_layout.addWidget(replace_frame)
        
        # 获取当前段落文本
        
        text = self.segments[self.current_segment_index]
        
        
        # 分析文本，获取旁白和对话
        segments = self.analyze_text_segments(text)
        
        # 获取全局旁白预设和情绪（如果有）
        global_narration_preset = getattr(self, 'global_narration_preset', None)
        global_narration_emotion = getattr(self, 'global_narration_emotion', None)
        
        # 处理每个分段
        for segment_id, (segment_type, content, speaker) in enumerate(segments):
            # 创建分段容器
            segment_frame = QFrame()
            segment_frame.setStyleSheet(f"""
                QFrame {{
                    border: 1px solid #d4c5b9;
                    border-radius: 8px;
                    background-color: {('#faf6f1' if segment_type == 'narration' else '#ffffff')};
                    padding: 10px;
                    margin: 5px;
                }}
            """)
            segment_layout = QVBoxLayout(segment_frame)
            segment_layout.setSpacing(10)
            
            # 如果是对话，添加说话者标签
            if segment_type == "dialogue" and speaker:
                speaker_label = QLabel(f"说话者：{speaker}")
                speaker_label.setStyleSheet("""
                    color: #C67A8A;
                    font-weight: bold;
                    margin-bottom: 4px;
                """)
                segment_layout.addWidget(speaker_label)
            
            # 创建文本编辑区域和按钮
            text_container = QWidget()
            text_container_layout = QHBoxLayout(text_container)
            text_container_layout.setContentsMargins(0, 0, 0, 0)
            
            text_edit = QTextEdit()
            # 移除垂直滚动条设置，仅设置水平滚动条为隐藏
            text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            text_edit.setText(content)
            text_edit.setStyleSheet(f"""
                QTextEdit {{
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    padding: 8px;
                    background-color: {('#faf6f1' if segment_type == 'narration' else '#ffffff')};
                }}
            """)
            
            # 设置文本框ID
            text_edit_id = f"{self.current_segment_index}_{segment_id}"
            text_edit.setObjectName(text_edit_id)
            
            # 设置大小策略，允许垂直方向自动调整
            text_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            
            # 计算初始高度
            document = text_edit.document()
            document.setTextWidth(text_edit.viewport().width())
            text_height = int(document.size().height() + 20)
            text_edit.setFixedHeight(text_height)
            
            # 添加文本改变事件处理
            text_edit.textChanged.connect(lambda te=text_edit: self.adjust_text_height(te))
            
            # 添加文本框序号标签
            sequence_label = QLabel(f"{segment_id + 1}/{len(segments)}")
            sequence_label.setStyleSheet("""
                QLabel {
                    color: #C67A8A;
                    font-weight: bold;
                    font-size: 12px;
                    margin: 2px;
                }
            """)
            
            # 添加按钮容器
            button_container = QVBoxLayout()
            button_container.setSpacing(5)
            
            # 添加序号标签到按钮容器顶部
            button_container.addWidget(sequence_label)
            
            # 添加复制按钮
            copy_btn = QPushButton("复制")
            copy_btn.setStyleSheet("""
                QPushButton {
                    background-color: #C67A8A;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #B56A7A;
                }
            """)
            copy_btn.clicked.connect(lambda _, te=text_edit: self.copy_text_content(te))
            
            # 添加剪切按钮
            cut_btn = QPushButton("剪切")
            cut_btn.setStyleSheet("""
                QPushButton {
                    background-color: #C67A8A;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #B56A7A;
                }
            """)
            cut_btn.clicked.connect(lambda _, te=text_edit: self.cut_text_content(te))
            
            # 添加删除按钮
            delete_btn = QPushButton("删除")
            delete_btn.setStyleSheet("""
                QPushButton {
                    background-color: #C67A8A;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #B56A7A;
                }
            """)
            delete_btn.clicked.connect(lambda _, te=text_edit: self.delete_text_content(te))
            
            # 添加保存按钮
            save_btn = QPushButton("保存")
            save_btn.setStyleSheet("""
                QPushButton {
                    background-color: #C5D8EC;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #B5C8DC;
                }
            """)
            save_btn.clicked.connect(lambda _, te=text_edit: self.save_text_content(te))
            
            # 添加粘贴按钮
            paste_btn = QPushButton("粘贴")
            paste_btn.setStyleSheet("""
                QPushButton {
                    background-color: #C5D8EC;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #B5C8DC;
                }
            """)
            paste_btn.clicked.connect(lambda _, te=text_edit: self.paste_text_content(te))
            
            # 添加按钮到按钮容器
            button_container.addWidget(copy_btn)
            button_container.addWidget(cut_btn)
            button_container.addWidget(delete_btn)
            button_container.addWidget(save_btn)
            button_container.addWidget(paste_btn)
            button_container.addStretch()
            
            # 修改布局顺序：先添加按钮容器，然后添加文本框
            text_container_layout.addLayout(button_container)
            text_container_layout.addWidget(text_edit)
            
            # 创建控制面板
            control_panel = QWidget()
            control_layout = QHBoxLayout(control_panel)
            control_layout.setSpacing(10)
            
            # 配音选择
            voice_combo = SwipeSelector()
            all_presets = [preset[0] for preset in self.preset_manager.get_all_presets()]
            
            # 🔧 使用预设排序管理器进行排序
            if self.preset_order_manager:
                sorted_presets = self.preset_order_manager.sort_presets(all_presets)
                voice_combo.addItems(sorted_presets)
            else:
                voice_combo.addItems(all_presets)
            
            # 情绪选择
            emotion_combo = SwipeSelector()
            if segment_type == "dialogue" and speaker in self.characters:
                # 对话段落：根据说话者设置配音
                preset = self.characters[speaker]
                index = voice_combo.findText(preset)
                if index >= 0:
                    voice_combo.setCurrentIndex(index)
                # 从预设加载情绪选项
                emotions = self.preset_manager.get_preset_emotions(preset)
                emotion_combo.addItems(emotions)
                if emotions:
                    emotion_combo.setCurrentIndex(0)
            else:
                # 旁白段落或未识别到说话者的对话段落：优先使用全局旁白预设
                if global_narration_preset:
                    # 使用全局旁白预设
                    index = voice_combo.findText(global_narration_preset)
                    if index >= 0:
                        voice_combo.setCurrentIndex(index)
                    # 加载情绪选项
                    emotions = self.preset_manager.get_preset_emotions(global_narration_preset)
                    emotion_combo.addItems(emotions)
                    # 设置全局旁白情绪
                    if global_narration_emotion and global_narration_emotion in emotions:
                        emotion_index = emotion_combo.findText(global_narration_emotion)
                        if emotion_index >= 0:
                            emotion_combo.setCurrentIndex(emotion_index)
                        else:
                            # 如果没有匹配的情绪，选择第一个
                            if emotions:
                                emotion_combo.setCurrentIndex(0)
                    else:
                        # 如果没有全局情绪，选择第一个
                        if emotions:
                            emotion_combo.setCurrentIndex(0)
                else:
                    # 旁白段落但没有全局预设：使用第一个预设
                    if all_presets:
                        voice_combo.setCurrentIndex(0)
                        emotions = self.preset_manager.get_preset_emotions(all_presets[0])
                        emotion_combo.addItems(emotions)
                        if emotions:
                            emotion_combo.setCurrentIndex(0)
            
            # 生成和试听按钮
            generate_btn = QPushButton("生成")
            generate_btn.setObjectName("generate_btn")
            generate_btn.setStyleSheet("""
                QPushButton#generate_btn {
                    background-color: #C67A8A;
                    color: white;
                    border: none;
                }
                QPushButton#generate_btn:hover {
                    background-color: #B56A7A;
                }
                QPushButton#generate_btn:disabled {
                    background-color: #ffffff;
                    color: #4a5568;
                    border: 1px solid #d4c5b9;
                }
            """)
            
            regenerate_btn = QPushButton("重新生成")
            regenerate_btn.setObjectName("regenerate_btn")
            regenerate_btn.setEnabled(False)
            regenerate_btn.setStyleSheet("""
                QPushButton#regenerate_btn {
                    background-color: #ffffff;
                    color: #4a5568;
                    border: 1px solid #d4c5b9;
                }
                QPushButton#regenerate_btn:enabled {
                    background-color: #C67A8A;
                    color: white;
                    border: none;
                }
                QPushButton#regenerate_btn:enabled:hover {
                    background-color: #B56A7A;
                }
            """)
            
            preview_btn = QPushButton("试听")
            preview_btn.setEnabled(True)  # 默认启用试听按钮
            preview_btn.setStyleSheet("""
                QPushButton {
                    background-color: #ffffff;
                    color: #4a5568;
                    border: 1px solid #d4c5b9;
                }
                QPushButton:enabled {
                    background-color: #C67A8A;
                    color: white;
                    border: none;
                }
                QPushButton:enabled:hover {
                    background-color: #B56A7A;
                }
            """)
            
            # 状态标签
            status_label = QLabel("🔄")  # 初始状态：准备中
            status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            status_label.setStyleSheet("""
                QLabel {
                    font-size: 18px;
                    min-width: 30px;
                }
            """)
            
            # 连接信号
            voice_combo.currentTextChanged.connect(
                lambda text, ec=emotion_combo: self.on_voice_changed(text, ec))
            generate_btn.clicked.connect(
                lambda _, te=text_edit, vc=voice_combo, ec=emotion_combo, gb=generate_btn, rb=regenerate_btn, pb=preview_btn, sl=status_label:
                self.generate_audio(te, vc.currentText(), ec.currentText(), gb, rb, pb, sl, is_regenerate=False))
            regenerate_btn.clicked.connect(
                lambda _, te=text_edit, vc=voice_combo, ec=emotion_combo, gb=generate_btn, rb=regenerate_btn, pb=preview_btn, sl=status_label:
                self.generate_audio(te, vc.currentText(), ec.currentText(), gb, rb, pb, sl, is_regenerate=True))
            preview_btn.clicked.connect(
                lambda _, te=text_edit: self.preview_audio(te))
            
            # 添加控件到控制面板
            control_layout.addWidget(QLabel("配音:"))
            control_layout.addWidget(voice_combo)
            control_layout.addWidget(QLabel("情绪:"))
            control_layout.addWidget(emotion_combo)
            control_layout.addWidget(generate_btn)
            control_layout.addWidget(regenerate_btn)
            control_layout.addWidget(preview_btn)
            control_layout.addWidget(status_label)
            control_layout.addStretch()
            
            # 添加组件到分段容器
            segment_layout.addWidget(text_container)
            segment_layout.addWidget(control_panel)
            
            # 添加分段容器到内容布局
            self.content_layout.addWidget(segment_frame)
    
    def adjust_text_height(self, text_edit: QTextEdit):
        """调整文本框高度以适应内容"""
        # 计算新的高度
        document = text_edit.document()
        document.setTextWidth(text_edit.viewport().width())
        # 增加额外的边距确保所有内容可见
        new_height = int(document.size().height() + 30)
        text_edit.setFixedHeight(new_height)
    
    
    
    def on_voice_changed(self, preset_name: str, emotion_combo: QComboBox):
        """当预设选择改变时，更新情绪选项"""
        emotions = self.preset_manager.get_preset_emotions(preset_name)
        emotion_combo.clear()
        emotion_combo.addItems(emotions)
        if emotions:
            emotion_combo.setCurrentIndex(0)
    
    def on_default_changed(self, state: int, preset_name: str, emotion: str):
        """当默认选项改变时的处理"""
        # 不再需要这个方法，但为了避免报错，保留一个空实现
        pass
    
    def generate_audio(self, text_edit: QTextEdit, preset_name: str, emotion: str,
                       generate_btn: QPushButton, regenerate_btn: QPushButton, preview_btn: QPushButton, 
                       status_label: QLabel, is_regenerate: bool = False):
        """生成音频"""
        try:
            # 获取文本内容并检查是否为空
            text = text_edit.toPlainText().strip()
            if not text:
                status_label.setText("❓")  # 需要文本
                generate_btn.setEnabled(True)
                regenerate_btn.setEnabled(False)
                # 不再禁用试听按钮，让用户随时可以尝试试听
                return
                
            # 更新状态为处理中
            status_label.setText("⏳")  # 处理中
            QApplication.processEvents()  # 立即更新UI
            
            # 获取预设信息
            preset_info = self.preset_manager.get_preset(preset_name)
            if not preset_info:
                status_label.setText("❌")  # 错误
                return
                
            settings, audio_files = preset_info
            
            # 加载模型
            gpt_path = settings.get('model_path', '') or settings.get('gpt_path', '')
            if not self.gpt_sovits.load_models(gpt_path, settings['sovits_path']):
                status_label.setText("❌")  # 错误
                return
                
            # 设置预设参数，并添加情绪参数
            settings['ref_emotion'] = emotion  # 确保使用用户选择的情绪
            settings['preset_name'] = preset_name  # 添加预设名称
            
            # 确保设置包含gpt_sovits.py所需的所有必要字段
            if 'gpt_path' not in settings and 'model_path' in settings:
                settings['gpt_path'] = settings['model_path']
            if 'ref_language' not in settings:
                settings['ref_language'] = settings.get('text_lang', 'all_zh')
            
            if not self.gpt_sovits.set_preset(settings):
                status_label.setText("❌")  # 错误
                return
            
            # 尝试从MainWindow获取当前处理的文件名
            main_window = self.window()
            source_filename = "unknown"
            
            if hasattr(main_window, 'current_file') and main_window.current_file:
                # 从MainWindow获取当前文件路径
                source_filename = os.path.splitext(os.path.basename(main_window.current_file))[0]
            
            # 创建音频目录
            working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
            processed_dir = os.path.join(working_dir, f"{source_filename}_processed")
            audio_dir = os.path.join(processed_dir, "audio_segments")
            os.makedirs(audio_dir, exist_ok=True)
            
            # 生成音频文件名，包含原文件名、段落和框序号
            text_edit_id = text_edit.objectName()
            segment_index, box_index = map(int, text_edit_id.split('_'))
            audio_filename = f"{source_filename}_段落{segment_index+1:04d}_文本框{box_index+1:02d}.wav"
            audio_path = os.path.join(audio_dir, audio_filename)
            
            # 重要：先停止播放器，确保不会阻止文件替换
            try:
                self.player.stop()
            except:
                pass
                
            # 检查并删除可能存在的旧文件
            old_pattern = re.compile(rf'^.*_段落{segment_index+1:04d}_文本框{box_index+1:02d}.*\.wav$')
            for file in os.listdir(audio_dir):
                if old_pattern.match(file):
                    try:
                        old_file_path = os.path.join(audio_dir, file)
                        os.remove(old_file_path)
                    except Exception as e:
                        pass  # 无法删除旧文件
            
            # 记录开始生成语音的信息（便于调试）
            
            
            
            # 生成音频（不显示进度对话框）并明确传递情绪参数
            success = self.gpt_sovits.generate_audio(text, audio_path, emotion=emotion)
            
            if success:
                # 先检查文件是否确实存在
                if os.path.exists(audio_path):
        
                    
                    # 如果是重新生成，尝试重置播放器状态
                    if is_regenerate:
                        try:
                            # 重置播放器以清除可能的缓存
        
                            self.player.stop()
                            # 创建新的播放器实例
                            del self.player
                            del self.audio_output
                            
                            self.player = QMediaPlayer()
                            self.audio_output = QAudioOutput()
                            self.player.setAudioOutput(self.audio_output)
                            
                            # 恢复音量设置
                            self.audio_output.setVolume(self.current_volume / 100.0)
                        except Exception as e:
                            pass  # 重置播放器时出错，不影响生成结果
                    
                    # 保存音频状态
                    self.segment_audio_states[text_edit_id] = (True, audio_path)
                    
                    # 强制更新状态标签为成功
                    status_label.setText("🌷")  # 成功
                    QApplication.processEvents()  # 立即更新UI
                    
                    # 更新按钮状态
                    generate_btn.setEnabled(False)
                    regenerate_btn.setEnabled(True)
                    preview_btn.setEnabled(True)
                    
                    # 如果是重新生成，更新状态emoji和按钮状态
                    if is_regenerate:
    
                        status_label.setText("🥳")  # 确保状态为成功
                        preview_btn.setEnabled(True)  # 确保试听按钮可用
                    
                else:
                    pass  # 音频生成成功但文件不存在
                    status_label.setText("⚠️")  # 警告
                    QMessageBox.warning(self, "警告", "音频生成成功但文件不存在")
            else:
                # 更新状态为失败
                status_label.setText("❌")  # 错误

                
        except Exception as e:
            # 更新状态为失败
            status_label.setText("❌")  # 错误
    
    def preview_audio(self, text_edit: QTextEdit):
        """预览音频"""
        try:
            text_edit_id = text_edit.objectName()

            
            # 获取音频文件路径
            audio_path = None
            
            # 首先尝试从segment_audio_states获取路径
            if text_edit_id in self.segment_audio_states:
                is_generated, saved_path = self.segment_audio_states[text_edit_id]
                if is_generated and saved_path:
                    audio_path = saved_path
            
            # 如果没有找到路径或文件不存在，尝试重新构建路径
            if not audio_path or not os.path.exists(audio_path):
                
                # 尝试从MainWindow获取当前处理的文件名
                main_window = self.window()
                source_filename = "unknown"
                
                if hasattr(main_window, 'current_file') and main_window.current_file:
                    # 从MainWindow获取当前文件路径
                    source_filename = os.path.splitext(os.path.basename(main_window.current_file))[0]
                
                # 构建音频目录路径
                working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
                processed_dir = os.path.join(working_dir, f"{source_filename}_processed")
                audio_dir = os.path.join(processed_dir, "audio_segments")
                
                # 从文本框ID解析段落和框序号
                segment_index, box_index = map(int, text_edit_id.split('_'))
                audio_filename = f"{source_filename}_段落{segment_index+1:04d}_文本框{box_index+1:02d}.wav"
                constructed_path = os.path.join(audio_dir, audio_filename)
                
                # 检查文件是否存在
                if os.path.exists(constructed_path):
                    audio_path = constructed_path
                    # 更新缓存状态
                    self.segment_audio_states[text_edit_id] = (True, constructed_path)
            
            # 如果找到有效的音频文件，播放它
            if audio_path and os.path.exists(audio_path):
                # 🔧 彻底修复多人朗读模式播放问题：重新创建播放器实例
                try:
                    # 1. 销毁当前播放器
                    self.player.stop()
                    self.player.setSource(QUrl())  # 清空音频源
                    
                    # 2. 重新创建播放器和音频输出
                    old_volume = self.current_volume
                    del self.player
                    del self.audio_output
                    
                    self.player = QMediaPlayer()
                    self.audio_output = QAudioOutput()
                    self.player.setAudioOutput(self.audio_output)
                    
                    # 3. 恢复音量设置
                    self.audio_output.setVolume(old_volume / 100.0)
                    
                except Exception as cleanup_error:
                    logger.warning(f"多人模式播放器重建时出错: {cleanup_error}")
                
                # 4. 设置音频源并播放
                self.player.setSource(QUrl.fromLocalFile(audio_path))
                self.player.play()
                
                logger.info(f"开始播放音频: {audio_path}")
            else:
                QMessageBox.warning(self, "提示", "音频文件不存在，请生成音频")
        except Exception as e:
            QMessageBox.warning(self, "错误", f"播放音频时出错：{str(e)}")
            logger.error(f"播放音频时出错: {str(e)}")
    
    def update_nav_buttons(self):
        """更新导航按钮状态"""
        self.prev_btn.setEnabled(self.current_segment_index > 0)
        self.next_btn.setEnabled(self.current_segment_index < len(self.segments) - 1)
        self.segment_label.setText(f"第 {self.current_segment_index + 1}/{len(self.segments)} 段")
        
        # 更新底部导航按钮
        self.bottom_prev_btn.setEnabled(self.current_segment_index > 0)
        self.bottom_next_btn.setEnabled(self.current_segment_index < len(self.segments) - 1)
        self.bottom_segment_label.setText(f"第 {self.current_segment_index + 1}/{len(self.segments)} 段")
    
    def prev_segment(self):
        """显示上一段"""
        if self.current_segment_index > 0:
            # 保存当前配置状态
            current_preset_selections = self._save_current_preset_selections()
            global_narration_preset = getattr(self, 'global_narration_preset', None)
            global_narration_emotion = getattr(self, 'global_narration_emotion', None)
            
            # 更新段落索引
            self.current_segment_index -= 1
            
            # 清空现有内容，确保正确重新加载
            for i in reversed(range(self.content_layout.count())):
                widget = self.content_layout.itemAt(i).widget()
                if widget:
                    widget.deleteLater()
            
            # 使用process_current_segment重新分析并加载段落
            self.process_current_segment()
            
            # 恢复全局预设和旁白配置
            self._restore_global_narration_preset(global_narration_preset, global_narration_emotion)
            
            # 更新导航按钮状态
            self.update_nav_buttons()
    
    def next_segment(self):
        """显示下一段"""
        if self.current_segment_index < len(self.segments) - 1:
            # 保存当前配置状态
            current_preset_selections = self._save_current_preset_selections()
            global_narration_preset = getattr(self, 'global_narration_preset', None)
            global_narration_emotion = getattr(self, 'global_narration_emotion', None)
            
            # 更新段落索引
            self.current_segment_index += 1
            
            # 清空现有内容，确保正确重新加载
            for i in reversed(range(self.content_layout.count())):
                widget = self.content_layout.itemAt(i).widget()
                if widget:
                    widget.deleteLater()
            
            # 使用process_current_segment重新分析并加载段落
            self.process_current_segment()
            
            # 恢复全局预设和旁白配置
            self._restore_global_narration_preset(global_narration_preset, global_narration_emotion)
            
            # 更新导航按钮状态
            self.update_nav_buttons()
    
    def _save_current_preset_selections(self):
        """保存当前文本框的预设选择状态"""
        preset_selections = {}
        
        # 遍历内容布局中的所有控件
        for i in range(self.content_layout.count()):
            widget = self.content_layout.itemAt(i).widget()
            # 跳过全局替换框
            if i == 0 and isinstance(widget, QFrame) and "全局文本替换" in widget.findChildren(QLabel)[0].text():
                continue
                
            if isinstance(widget, QFrame):
                # 找到文本框和控制面板
                text_edit = None
                voice_combo = None
                emotion_combo = None
                
                # 查找文本框
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    # 查找文本框容器
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        for k in range(item.layout().count()):
                            sub_item = item.layout().itemAt(k).widget()
                            if isinstance(sub_item, QTextEdit):
                                text_edit = sub_item
                                break
                
                # 查找控制面板
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        control_layout = item.layout()
                        # 查找预设和情绪下拉框
                        found_combos = []
                        for k in range(control_layout.count()):
                            control_item = control_layout.itemAt(k).widget()
                            if isinstance(control_item, QComboBox):
                                found_combos.append(control_item)
                                
                        if len(found_combos) >= 2:
                            voice_combo = found_combos[0]
                            emotion_combo = found_combos[1]
                
                # 如果找到了所有需要的控件，保存预设选择状态
                if text_edit and voice_combo and emotion_combo:
                    text_edit_id = text_edit.objectName()
                    preset_selections[text_edit_id] = {
                        'preset': voice_combo.currentText(),
                        'emotion': emotion_combo.currentText(),
                        'text': text_edit.toPlainText(),
                        'is_narration': 'faf6f1' in widget.styleSheet(),
                        'has_speaker': any(isinstance(w, QLabel) and "说话者" in w.text() 
                                         for w in widget.findChildren(QLabel))
                    }
        
        return preset_selections
    
    def _restore_global_narration_preset(self, global_narration_preset, global_narration_emotion):
        """恢复全局旁白预设选择"""
        if global_narration_preset and global_narration_emotion:
            self.global_narration_preset = global_narration_preset
            self.global_narration_emotion = global_narration_emotion
            
            # 恢复旁白下拉框的选择
            replace_frame = self.content_layout.itemAt(0).widget()
            if replace_frame:
                # 查找旁白预设下拉框
                narration_combos = []
                for child in replace_frame.findChildren(QComboBox):
                    narration_combos.append(child)
                
                if len(narration_combos) >= 2:
                    narration_preset_combo = narration_combos[0]
                    narration_emotion_combo = narration_combos[1]
                    
                    # 恢复选择
                    preset_index = narration_preset_combo.findText(global_narration_preset)
                    if preset_index >= 0:
                        narration_preset_combo.setCurrentIndex(preset_index)
                        
                        # 加载情绪选项
                        emotions = self.preset_manager.get_preset_emotions(global_narration_preset)
                        narration_emotion_combo.clear()
                        narration_emotion_combo.addItems(emotions)
                        
                        # 设置情绪
                        emotion_index = narration_emotion_combo.findText(global_narration_emotion)
                        if emotion_index >= 0:
                            narration_emotion_combo.setCurrentIndex(emotion_index)
    
    def global_replace(self, search_text: str, replace_text: str):
        """全局替换文本"""
        if not search_text:
            QMessageBox.warning(self, "提示", "请输入要查找的文本")
            return
            
        # 保存当前配置状态
        current_preset_selections = self._save_current_preset_selections()
        global_narration_preset = getattr(self, 'global_narration_preset', None)
        global_narration_emotion = getattr(self, 'global_narration_emotion', None)
        
        # 替换所有段落中的文本
        replace_count = 0
        for i in range(len(self.segments)):
            if search_text in self.segments[i]:
                self.segments[i] = self.segments[i].replace(search_text, replace_text)
                replace_count += self.segments[i].count(replace_text)
        
        # 将替换记录添加到历史中
        replace_history_manager.add_replace_record(search_text, replace_text)
        
        # 清空现有内容，确保正确重新加载
        for i in reversed(range(self.content_layout.count())):
            widget = self.content_layout.itemAt(i).widget()
            if widget:
                widget.deleteLater()
        
        # 重新处理当前段落，这将使用analyze_text_segments重新识别对话
        self.process_current_segment()
        
        # 恢复全局预设和旁白配置
        self._restore_global_narration_preset(global_narration_preset, global_narration_emotion)
        
        # 恢复各文本框的预设选择
        # 注意：因为文本分段可能发生变化，需要根据文本框ID进行匹配
        for i in range(self.content_layout.count()):
            widget = self.content_layout.itemAt(i).widget()
            # 跳过全局替换框
            if i == 0 and isinstance(widget, QFrame) and "全局文本替换" in widget.findChildren(QLabel)[0].text():
                continue
                
            if isinstance(widget, QFrame):
                # 找到文本框和控制面板
                text_edit = None
                voice_combo = None
                emotion_combo = None
                
                # 查找文本框
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    # 查找文本框容器
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        for k in range(item.layout().count()):
                            sub_item = item.layout().itemAt(k).widget()
                            if isinstance(sub_item, QTextEdit):
                                text_edit = sub_item
                                break
                
                # 查找控制面板
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        control_layout = item.layout()
                        # 查找预设和情绪下拉框
                        found_combos = []
                        for k in range(control_layout.count()):
                            control_item = control_layout.itemAt(k).widget()
                            if isinstance(control_item, QComboBox):
                                found_combos.append(control_item)
                                
                        if len(found_combos) >= 2:
                            voice_combo = found_combos[0]
                            emotion_combo = found_combos[1]
                
                # 如果找到了所有需要的控件，尝试恢复预设选择状态
                if text_edit and voice_combo and emotion_combo:
                    text_edit_id = text_edit.objectName()
                    # 首先尝试精确匹配ID
                    if text_edit_id in current_preset_selections:
                        # 恢复预设选择
                        preset_info = current_preset_selections[text_edit_id]
                        preset = preset_info['preset']
                        preset_index = voice_combo.findText(preset)
                        if preset_index >= 0:
                            voice_combo.setCurrentIndex(preset_index)
                            
                            # 恢复情绪选择
                            emotion = preset_info['emotion']
                            emotions = self.preset_manager.get_preset_emotions(preset)
                            emotion_combo.clear()
                            emotion_combo.addItems(emotions)
                            
                            emotion_index = emotion_combo.findText(emotion)
                            if emotion_index >= 0:
                                emotion_combo.setCurrentIndex(emotion_index)
                    else:
                        # 如果不能精确匹配ID，尝试根据段落类型寻找匹配的预设
                        segment_frame = widget
                        is_narration = 'faf6f1' in segment_frame.styleSheet()
                        has_speaker_label = any(isinstance(w, QLabel) and "说话者" in w.text() 
                                               for w in segment_frame.findChildren(QLabel))
                        
                        # 对于旁白段落，应用全局旁白预设（如果有）
                        if is_narration and not has_speaker_label and global_narration_preset:
                            preset_index = voice_combo.findText(global_narration_preset)
                            if preset_index >= 0:
                                voice_combo.setCurrentIndex(preset_index)
                                
                                # 设置情绪
                                emotions = self.preset_manager.get_preset_emotions(global_narration_preset)
                                emotion_combo.clear()
                                emotion_combo.addItems(emotions)
                                
                                if global_narration_emotion and global_narration_emotion in emotions:
                                    emotion_index = emotion_combo.findText(global_narration_emotion)
                                    if emotion_index >= 0:
                                        emotion_combo.setCurrentIndex(emotion_index)
                        
                        # 对于对话段落，查找与角色匹配的预设
                        if has_speaker_label:
                            speaker_label = next((w for w in segment_frame.findChildren(QLabel) 
                                                if "说话者" in w.text()), None)
                            if speaker_label:
                                speaker_name = speaker_label.text().replace("说话者：", "")
                                # 根据说话者找到对应的预设
                                for character, preset_name in self.characters.items():
                                    if character == speaker_name:
                                        preset_index = voice_combo.findText(preset_name)
                                        if preset_index >= 0:
                                            voice_combo.setCurrentIndex(preset_index)
                                            
                                            # 设置第一个情绪（如果有）
                                            emotions = self.preset_manager.get_preset_emotions(preset_name)
                                            emotion_combo.clear()
                                            emotion_combo.addItems(emotions)
                                            
                                            if emotions:
                                                emotion_combo.setCurrentIndex(0)
                                        break
        
        QMessageBox.information(self, "成功", f"已全局替换 {search_text} 为 {replace_text}，共替换了 {replace_count} 处文本")
    
    def copy_text_content(self, text_edit: QTextEdit):
        """复制文本框内容到剪贴板"""
        text = text_edit.toPlainText()
        clipboard = QApplication.clipboard()
        clipboard.setText(text)
        QMessageBox.information(self, "提示", "文本已复制到剪贴板")
    
    def cut_text_content(self, text_edit: QTextEdit):
        """剪切文本框内容到剪贴板"""
        text = text_edit.toPlainText()
        clipboard = QApplication.clipboard()
        clipboard.setText(text)
        text_edit.clear()
        QMessageBox.information(self, "提示", "文本已剪切到剪贴板")
    
    def delete_text_content(self, text_edit: QTextEdit):
        """删除文本框内容"""
        # 直接清除文本内容
        text_edit.clear()
        
        # 视觉反馈
        button = self.sender()
        if button:
            original_style = button.styleSheet()
            button.setStyleSheet("""
                QPushButton {
                    background-color: #C5D8EC;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
            """)
            QTimer.singleShot(500, lambda: button.setStyleSheet(original_style))
    
    def save_text_content(self, text_edit: QTextEdit):
        """保存文本框内容到processed文件，更新segments.txt文件"""
        try:
            # 获取当前文本
            new_text = text_edit.toPlainText()
            
            # 获取当前文本框ID，解析出段落和框序号
            text_edit_id = text_edit.objectName()
            parts = text_edit_id.split('_')
            if len(parts) >= 2:
                segment_index = int(parts[0])
                
                # 找出当前段落的所有文本框内容
                segment_text_edits = []
                
                # 遍历当前布局中的所有框，找出属于当前段落的文本框
                for i in range(1, self.content_layout.count()):  # 跳过第0个全局替换框
                    widget = self.content_layout.itemAt(i).widget()
                    if isinstance(widget, QFrame):
                        # 查找文本框
                        for j in range(widget.layout().count()):
                            item = widget.layout().itemAt(j).widget()
                            if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                                for k in range(item.layout().count()):
                                    sub_item = item.layout().itemAt(k).widget()
                                    if isinstance(sub_item, QTextEdit):
                                        item_id = sub_item.objectName()
                                        if item_id.startswith(f"{segment_index}_"):
                                            segment_text_edits.append((item_id, sub_item.toPlainText()))
                
                # 按ID排序，确保文本框顺序正确
                segment_text_edits.sort(key=lambda x: x[0])
                
                # 将这个段落的所有文本框内容合并成完整的段落文本
                combined_text = ''.join([text for _, text in segment_text_edits])
                
                # 更新内存中的segments数组
        
                
                
                # 查找processed文件夹和segments.txt文件
                main_window = self.window()
                source_filename = "unknown"
                
                if hasattr(main_window, 'current_file') and main_window.current_file:
                    # 从MainWindow获取当前文件路径
                    source_filename = os.path.splitext(os.path.basename(main_window.current_file))[0]
                
                working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
                processed_dir = os.path.join(working_dir, f"{source_filename}_processed")
                segments_file = os.path.join(processed_dir, "segments.txt")
                
                # 如果文件存在，读取现有内容，然后更新对应段落
                if os.path.exists(segments_file):
                    # 读取文件内容
                    with open(segments_file, 'r', encoding='utf-8') as f:
                        lines = f.readlines()
                    
                    # 找到对应段落的开始和结束行
                    start_line = -1
                    end_line = -1
                    current_segment = -1
                    
                    for i, line in enumerate(lines):
                        if line.startswith(f"[段落 {segment_index + 1}]"):
                            start_line = i
                            current_segment = segment_index
                        elif current_segment == segment_index and line.startswith("[段落 "):
                            end_line = i
                            break
                    
                    # 如果找到了结束行，则更新内容
                    if start_line != -1:
                        if end_line == -1:  # 如果是最后一段，结束行是文件末尾
                            end_line = len(lines)
                        
                        # 替换段落内容
                        new_content = [f"[段落 {segment_index + 1}]\n", combined_text + "\n\n"]
                        lines[start_line:end_line] = new_content
                        
                        # 写回文件
                        with open(segments_file, 'w', encoding='utf-8') as f:
                            f.writelines(lines)
                        
                        QMessageBox.information(self, "成功", f"已保存段落 {segment_index + 1} 的更改到文件")
                    else:
                        QMessageBox.warning(self, "错误", f"未找到段落 {segment_index + 1} 在文件中的位置")
                else:
                    QMessageBox.warning(self, "错误", f"找不到处理文件：{segments_file}")
            else:
                QMessageBox.warning(self, "错误", "无法解析文本框ID")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"保存文本时出错：{str(e)}")
    
    def paste_text_content(self, text_edit: QTextEdit):
        """将剪贴板内容附加到文本框末尾"""
        try:
            # 获取剪贴板内容
            clipboard = QApplication.clipboard()
            text = clipboard.text()
            
            if not text:
                QMessageBox.information(self, "提示", "剪贴板为空")
                return
            
            # 获取当前文本框内容
            current_text = text_edit.toPlainText()
            
            # 附加剪贴板内容到文本框末尾
            text_edit.setText(current_text + text)
            
            # 将光标移到末尾
            cursor = text_edit.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            text_edit.setTextCursor(cursor)
            
        except Exception as e:
            QMessageBox.critical(self, "错误", f"粘贴文本时出错：{str(e)}")
    
    def show_preset_management(self):
        """显示预设管理页面"""
        # 保存当前段落索引，以便返回时恢复
        self.saved_segment_index = self.current_segment_index
        
        # 保存当前文本框的所有预设和情绪选择状态
        self.saved_preset_selections = self._save_current_preset_selections()
        
        # 保存全局旁白预设（如果有）
        self.saved_global_narration_preset = getattr(self, 'global_narration_preset', None)
        self.saved_global_narration_emotion = getattr(self, 'global_narration_emotion', None)
        
        # 获取主窗口
        main_window = self.window()
        if isinstance(main_window, MainWindow):
            # 设置一个标识，表示是从段落页面跳转过来的
            self.is_from_segment_process = True
            # 调用主窗口的预设管理方法
            main_window.show_preset_setting(source_page="segment")
    
    def generate_all_audio(self):
        """一键生成所有文本框的音频"""
        # 收集所有需要生成的文本框信息
        text_boxes = []
        
        # 遍历内容布局中的所有文本框
        for i in range(self.content_layout.count()):
            widget = self.content_layout.itemAt(i).widget()
            # 跳过全局替换框
            if i == 0 and isinstance(widget, QFrame) and "全局文本替换" in widget.findChildren(QLabel)[0].text():
                continue
                
            if isinstance(widget, QFrame):
                # 找到文本框和控制面板
                text_edit = None
                voice_combo = None
                emotion_combo = None
                generate_btn = None
                regenerate_btn = None
                preview_btn = None
                status_label = None
                
                # 查找文本框
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    # 查找文本框容器
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        for k in range(item.layout().count()):
                            sub_item = item.layout().itemAt(k).widget()
                            if isinstance(sub_item, QTextEdit):
                                text_edit = sub_item
                                break
                
                # 查找控制面板
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        control_layout = item.layout()
                        # 查找控件
                        for k in range(control_layout.count()):
                            control_item = control_layout.itemAt(k).widget()
                            if isinstance(control_item, QComboBox):
                                if voice_combo is None:
                                    voice_combo = control_item
                                elif emotion_combo is None:
                                    emotion_combo = control_item
                            elif isinstance(control_item, QPushButton):
                                if "生成" == control_item.text():
                                    generate_btn = control_item
                                elif "重新生成" == control_item.text():
                                    regenerate_btn = control_item
                                elif "试听" == control_item.text():
                                    preview_btn = control_item
                            elif isinstance(control_item, QLabel) and control_item.text() in ["🔄", "⏳", "🌷", "🥳","❌", "❓"]:
                                status_label = control_item
                
                # 如果找到了所有需要的控件，并且文本框非空
                if text_edit and voice_combo and emotion_combo and text_edit.toPlainText().strip():
                    text_boxes.append((text_edit, voice_combo, emotion_combo, generate_btn, regenerate_btn, preview_btn, status_label))
        
        if not text_boxes:
            QMessageBox.information(self, "提示", "没有找到需要生成的文本")
            return
        
        # 创建进度对话框
        progress = QProgressDialog("正在生成音频...", "取消", 0, len(text_boxes), self)
        progress.setWindowTitle("批量生成")
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumWidth(300)
        progress.show()
        
        # 新增变量记录前一个文本框字数
        prev_char_count = 0
        
        # 生成每个文本框的音频
        for i, (text_edit, voice_combo, emotion_combo, generate_btn, regenerate_btn, preview_btn, status_label) in enumerate(text_boxes):
            # 更新进度
            progress.setValue(i)
            progress.setLabelText(f"正在生成 {i+1}/{len(text_boxes)}")
            
            # 添加等待逻辑（从第二个文本框开始）
            if i > 0:
                time.sleep(prev_char_count/2)  # 使用前一个文本框的字数作为等待秒数
            
            # 如果用户取消，则中断
            if progress.wasCanceled():
                break
            
            # 生成音频
            preset_name = voice_combo.currentText()
            emotion = emotion_combo.currentText()
            self.generate_audio(text_edit, preset_name, emotion, generate_btn, regenerate_btn, preview_btn, status_label)
            
            # 记录当前文本框字数供下一个循环使用
            prev_char_count = len(text_edit.toPlainText().strip())
            
            # 处理事件，保持UI响应
            QApplication.processEvents()
        
        # 关闭进度对话框
        progress.close()
        
        # 显示完成消息
        QMessageBox.information(self, "完成", "所有音频生成完成！")
    
    def merge_segment_audio(self):
        """合并当前段落所有音频"""
        # 获取原始文件名（不含扩展名和路径）
        # 尝试从MainWindow获取当前处理的文件名
        main_window = self.window()
        source_filename = "segment"
        
        if hasattr(main_window, 'current_file') and main_window.current_file:
            # 从MainWindow获取当前文件路径
            source_filename = os.path.splitext(os.path.basename(main_window.current_file))[0]
        
        # 创建Working目录中的保存路径
        working_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Working")
        processed_dir = os.path.join(working_dir, f"{source_filename}_processed")
        audio_dir = os.path.join(processed_dir, "audio_segments")
        
        # 检查音频目录是否存在
        if not os.path.exists(audio_dir):
            QMessageBox.warning(self, "警告", "音频目录不存在")
            return
        
        # 获取当前段落所有非空文本框
        text_boxes = []
        text_box_contents = {}
        
        # 遍历内容布局中的所有文本框
        for i in range(self.content_layout.count()):
            widget = self.content_layout.itemAt(i).widget()
            # 跳过全局替换框
            if i == 0 and isinstance(widget, QFrame) and "全局文本替换" in widget.findChildren(QLabel)[0].text():
                continue
                
            if isinstance(widget, QFrame):
                # 查找文本框
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    # 查找文本框容器
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        for k in range(item.layout().count()):
                            sub_item = item.layout().itemAt(k).widget()
                            if isinstance(sub_item, QTextEdit):
                                text_edit = sub_item
                                text_content = text_edit.toPlainText().strip()
                                if text_content:  # 只处理非空文本框
                                    text_edit_id = text_edit.objectName()
                                    try:
                                        _, box_idx = map(int, text_edit_id.split('_'))
                                        text_boxes.append(box_idx)
                                        text_box_contents[box_idx] = text_content
                                    except Exception as e:
                                        pass  # 解析文本框ID出错
                                break
        
        if not text_boxes:
            QMessageBox.warning(self, "警告", "段落中没有非空文本框")
            return
        
        text_boxes = [i + 1 for i in text_boxes]

        
            
        # 直接从音频目录查找所有匹配当前段落的音频文件
        audio_files = []
        found_audio_box_indices = set()
        
        # 创建匹配当前段落的正则表达式
        import re
        # 段落序号可能是多位数，前面可能有0填充
        segment_pattern = rf"{re.escape(source_filename)}_段落0*{self.current_segment_index + 1}_文本框(\d+)\.wav"
        segment_regex = re.compile(segment_pattern)
        

        
        # 遍历音频目录中的所有文件
        for filename in os.listdir(audio_dir):
            match = segment_regex.match(filename)
            if match:
                try:
                    # 提取文本框序号
                    box_idx = int(match.group(1))
                    audio_path = os.path.join(audio_dir, filename)
                    audio_files.append((box_idx, audio_path))
                    found_audio_box_indices.add(box_idx)
                except Exception as e:
                    continue  # 无法解析文件名
        
        # 如果没有找到音频文件，尝试从self.segment_audio_states获取（兼容旧逻辑）
        if not audio_files:
            
            for text_edit_id, (is_generated, audio_path) in self.segment_audio_states.items():
                segment_idx, box_idx = map(int, text_edit_id.split('_'))
                if segment_idx == self.current_segment_index and is_generated and os.path.exists(audio_path):
                    audio_files.append((box_idx, audio_path))
                    found_audio_box_indices.add(box_idx)
        
        if not audio_files:
            QMessageBox.warning(self, "警告", "没有找到可合并的音频文件")
            return
        
        # 检查是否所有非空文本框都有对应的音频文件
        missing_boxes = []
        for box_idx in text_boxes:
            if box_idx not in found_audio_box_indices:
                missing_boxes.append(box_idx)
        
        
        if missing_boxes:
            missing_details = []
            for box_idx in missing_boxes:
                # 截取前30个字符加省略号，作为内容预览
                content_preview = text_box_contents[box_idx-1][:30]
                if len(text_box_contents[box_idx-1]) > 30:
                    content_preview += "..."
                missing_details.append(f"文本框{box_idx}: {content_preview}")
                
            missing_info = "\n".join(missing_details)
            
            reply = QMessageBox.question(
                self,
                "音频文件不完整",
                f"以下{len(missing_boxes)}个文本框没有对应的音频文件:\n{missing_info}\n\n是否仍要继续合并?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.No:
                return
        
        # 按照框序号排序
        audio_files.sort()

        
        # 创建段落合并音频目录
        merged_segments_dir = os.path.join(processed_dir, "merged_segments")
        os.makedirs(merged_segments_dir, exist_ok=True)
        
        # 生成合并音频的文件名
        output_file = os.path.join(merged_segments_dir, f"{source_filename}_段落{self.current_segment_index + 1}.wav")
        
        try:
            # 使用外部命令合并音频
            from pydub import AudioSegment
            
            # 合并音频
            combined = AudioSegment.empty()
            for _, audio_path in audio_files:
                segment = AudioSegment.from_wav(audio_path)
                combined += segment
            
            # 导出合并后的音频（自动覆盖已存在的文件）
            combined.export(output_file, format="wav")
            
            QMessageBox.information(self, "成功", f"音频已合并并保存为:\n{output_file}")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"合并音频失败: {str(e)}")
    
    def analyze_text_segments(self, text: str) -> List[Tuple[str, str, Optional[str]]]:
        """
        分析文本，将其分割为旁白和对话段落
        返回格式：List of (segment_type, content, speaker)
            segment_type: "narration" 或 "dialogue"
            content: 段落内容
            speaker: 说话者（对话时）或 None（旁白时）
        """
        
        
        # 统一文本编码和引号
        
        # 确保文本是UTF-8编码
        if not isinstance(text, str):
            text = text.decode('utf-8')
        
        # 修改后的对话识别算法
        
        segments = []
        last_end = 0
        
        # 查找所有中文左引号"\u201c"和中文右引号"\u201d"的位置
        left_quotes = []
        right_quotes = []
        
        for i, char in enumerate(text):
            if char == '\u201c':  # 中文左引号
                left_quotes.append(i)
            elif char == '\u201d':  # 中文右引号
                right_quotes.append(i)
        
        
        
        # 标点符号列表
        punctuation_marks = "，。！？…～，~,.!?"
        
        dialogue_count = 0
        narration_count = 0
        
        i = 0  # 左引号索引
        j = 0  # 右引号索引
        
        # 匹配左右引号对
        while i < len(left_quotes) and j < len(right_quotes):
            start_quote_pos = left_quotes[i]
            
            # 找到下一个在左引号之后的右引号
            while j < len(right_quotes) and right_quotes[j] <= start_quote_pos:
                j += 1
                
            if j >= len(right_quotes):
                break  # 没有更多右引号
                
            end_quote_pos = right_quotes[j]
            
            # 检查是否满足条件：右引号的左边一个字符必须是指定的标点符号
            is_valid_dialogue = False
            if end_quote_pos > 1 and end_quote_pos - 1 < len(text):
                last_char_before_right_quote = text[end_quote_pos - 1]
                is_valid_dialogue = last_char_before_right_quote in punctuation_marks
            
            
            
            # 提取潜在的对话内容（不包括引号）
            dialogue_content = text[start_quote_pos + 1:end_quote_pos]
            
            
            # 如果内容合法（右引号前是标点符号），则视为对话
            if is_valid_dialogue:
                # 如果对话前有内容，添加为旁白
                if start_quote_pos > last_end:
                    narration = text[last_end:start_quote_pos].strip()
                    if narration:
                        narration_count += 1
                        
                        
                        # 获取旁白的最后150字符
                        narration_last_chars = narration[-150:] if len(narration) > 150 else narration
                        
                        
                        
                        segments.append(("narration", narration, None))
                
                # 分析对话上下文，查找说话者
                context_start = max(0, start_quote_pos - 150)  # 向前查找150个字符
                context_end = start_quote_pos
                context = text[context_start:context_end]
                
                # 查找说话者
                speaker = None
                closest_match_position = -1  # 记录最近匹配的位置
                closest_speaker = None       # 最近的说话者
                
                
                for char, preset in self.characters.items():
                    
                    # 获取预设信息
                    preset_info = self.preset_manager.get_preset(preset)
                    if preset_info and preset_info[0].get('character_info'):
                        char_info = preset_info[0]['character_info']
                        # 提取姓氏（应使用预设中的姓氏）
                        full_name = char_info.get('name', '')
                        surname = char_info.get('surname', '')
                        if not surname and full_name:
                            surname = full_name[:1]  # 如果没有预设姓氏，使用名字的第一个字符
                        
                        # 检查姓名、小名、姓氏是否在上下文中
                        name_patterns = [
                            char,  # 原名
                            full_name,  # 预设姓名
                            char_info.get('nickname', ''),  # 预设小名
                            surname  # 姓氏
                        ]
                        
                        
                        # 查找每个模式最后一次出现的位置（离对话最近）
                        for pattern in name_patterns:
                            if pattern and pattern in context:
                                # 找到这个模式最后一次出现的位置
                                last_pos = context.rfind(pattern)
                                if last_pos > closest_match_position:
                                    closest_match_position = last_pos
                                    closest_speaker = char
                                    
                
                # 使用找到的最近说话者
                if closest_speaker:
                    speaker = closest_speaker
                    
            
                
                # 获取对话的最后150字符
                dialogue_last_chars = dialogue_content[-150:] if len(dialogue_content) > 150 else dialogue_content
                dialogue_count += 1
                
                
                
                # 添加对话段落
                segments.append(("dialogue", dialogue_content, speaker))
                last_end = end_quote_pos + 1
            else:
                # 将这个不符合要求的对话视为普通文本的一部分，不做特别处理
                pass
            
            # 移到下一个左引号
            i += 1
            # 右引号已经用过，也移到下一个
            j += 1
        
        # 如果最后还有内容，添加为旁白
        if last_end < len(text):
            narration = text[last_end:].strip()
            if narration:
                narration_count += 1
        
                
                # 获取旁白的最后150字符
                narration_last_chars = narration[-150:] if len(narration) > 150 else narration
                
                
                
                segments.append(("narration", narration, None))
        
        
        
        # 最终段落详细信息
        for i, (type_, content, speaker) in enumerate(segments, 1):
            # 获取段落的最后150字符
            segment_last_chars = content[-150:] if len(content) > 150 else content
            
            
        

        
        return segments

    def save_narration_preset(self, preset_name: str):
        """保存选择的旁白预设"""
        self.global_narration_preset = preset_name
    
    def save_narration_emotion(self, emotion: str):
        """保存选择的旁白情绪"""
        self.global_narration_emotion = emotion
    
    def on_narration_preset_changed(self, preset_name: str, emotion_combo: QComboBox):
        """当旁白预设选择改变时，更新情绪选项"""
        emotions = self.preset_manager.get_preset_emotions(preset_name)
        emotion_combo.clear()
        emotion_combo.addItems(emotions)
        if emotions:
            emotion_combo.setCurrentIndex(0)
    
    def apply_narration_preset(self, preset_name: str, emotion: str):
        """应用旁白预设到所有旁白段落和没有识别到说话者的对话段落"""
        if not preset_name:
            QMessageBox.warning(self, "提示", "请选择旁白预设")
            return
            
        # 查找当前段落中所有旁白文本框和没有识别到说话者的对话段落
        updated_segments = 0
        
        # 从第1个widget开始遍历，跳过第0个widget（全局替换框）
        for i in range(1, self.content_layout.count()):
            widget = self.content_layout.itemAt(i).widget()
            if isinstance(widget, QFrame):
                # 查找在该框架内的第一个QTextEdit，检查它是否是旁白类型
                text_edit = None
                for j in range(widget.layout().count()):
                    item = widget.layout().itemAt(j).widget()
                    if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                        for k in range(item.layout().count()):
                            sub_item = item.layout().itemAt(k).widget()
                            if isinstance(sub_item, QTextEdit):
                                text_edit = sub_item
                                break
                        if text_edit:
                            break
                
                # 检查这个文本框是否对应的是旁白段落或没有识别到说话者的对话段落
                if text_edit and hasattr(text_edit, "objectName"):
                    text_edit_id = text_edit.objectName()
                    segment_idx, box_idx = map(int, text_edit_id.split('_'))
                    
                    # 获取该段落的类型和说话者
                    segments = self.analyze_text_segments(self.segments[self.current_segment_index])
                    if box_idx < len(segments) and (
                        segments[box_idx][0] == "narration" or  # 旁白段落
                        (segments[box_idx][0] == "dialogue" and segments[box_idx][2] is None)  # 没有识别到说话者的对话段落
                    ):
                        # 这是需要应用全局旁白预设的段落
                        updated_segments += 1
                        
                        # 查找控制面板
                        control_panel = None
                        for j in range(widget.layout().count()):
                            item = widget.layout().itemAt(j).widget()
                            if isinstance(item, QWidget) and item.layout() and isinstance(item.layout(), QHBoxLayout):
                                # 检查是否包含配音和情绪下拉框
                                has_voice_combo = False
                                has_emotion_combo = False
                                for k in range(item.layout().count()):
                                    sub_item = item.layout().itemAt(k).widget()
                                    if isinstance(sub_item, QLabel) and "配音" in sub_item.text():
                                        has_voice_combo = True
                                    if isinstance(sub_item, QLabel) and "情绪" in sub_item.text():
                                        has_emotion_combo = True
                                
                                if has_voice_combo and has_emotion_combo:
                                    control_panel = item
                                    break
                
                        if control_panel:
                            # 设置预设
                            preset_combo = None
                            emotion_combo = None
                            
                            # 查找预设和情绪下拉框
                            for j in range(control_panel.layout().count()):
                                item = control_panel.layout().itemAt(j).widget()
                                if isinstance(item, QComboBox):
                                    if not preset_combo:
                                        preset_combo = item  # 第一个下拉框是预设
                                    else:
                                        emotion_combo = item  # 第二个下拉框是情绪
                                        break
                            
                            # 应用预设和情绪
                            if preset_combo:
                                index = preset_combo.findText(preset_name)
                                if index >= 0:
                                    preset_combo.setCurrentIndex(index)
                                    segment_type = "旁白" if segments[box_idx][0] == "narration" else "无说话者对话"
                        
                            
                            # 应用情绪（如果找到了情绪下拉框且有对应的情绪选项）
                            if emotion_combo:
                                index = emotion_combo.findText(emotion)
                                if index >= 0:
                                    emotion_combo.setCurrentIndex(index)
                                    
        
        if updated_segments > 0:
            QMessageBox.information(self, "成功", f"已将全局预设应用到 {updated_segments} 个段落（包括旁白和未识别说话者的对话）")
        else:
            QMessageBox.information(self, "提示", "当前段落中没有找到旁白段落或未识别说话者的对话段落")
    
    def cut_text_content(self, text_edit: QTextEdit):
        """剪切文本框内容到剪贴板"""
        text = text_edit.toPlainText()
        clipboard = QApplication.clipboard()
        clipboard.setText(text)
        text_edit.clear()
        
        # 视觉反馈
        button = self.sender()
        if button:
            original_style = button.styleSheet()
            button.setStyleSheet("""
                QPushButton {
                    background-color: #C5D8EC;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
            """)
            QTimer.singleShot(500, lambda: button.setStyleSheet(original_style))
            
    def delete_text_content(self, text_edit: QTextEdit):
        """删除文本框内容"""
        # 直接清除文本内容
        text_edit.clear()
        
        # 视觉反馈
        button = self.sender()
        if button:
            original_style = button.styleSheet()
            button.setStyleSheet("""
                QPushButton {
                    background-color: #C5D8EC;
                    color: white;
                    border: none;
                    padding: 5px;
                    max-width: 60px;
                    border-radius: 4px;
                }
            """)
            QTimer.singleShot(500, lambda: button.setStyleSheet(original_style))

    def set_position(self, position):
        """设置播放位置"""
        self.player.setPosition(position)
        
    def set_volume(self, volume):
        """设置音量大小"""
        # 获取系统音量设置，确保与系统音量同步
        system_volume = QMediaDevices.defaultAudioOutput().volume() * 100
        # 使用滑块设置的音量或系统音量（当滑块被用户移动时）
        if volume != self.current_volume:  # 用户手动调整了滑块
            # 将滑块的0-100值转换为QMediaPlayer的0.0-1.0音量值
            volume_value = volume / 100.0
            self.audio_output.setVolume(volume_value)
            # 保存音量设置，以便在切换段落或重新试听时保持一致
            self.current_volume = volume
        else:  # 系统音量改变
            # 更新滑块显示
            self.volume_slider.setValue(int(system_volume))
            # 更新音频输出音量
            self.audio_output.setVolume(system_volume / 100.0)
            # 保存当前音量设置
            self.current_volume = int(system_volume)

    def update_replace_history_combo(self, combo: QComboBox):
        """更新替换历史下拉框"""
        combo.clear()
        
        # 获取所有替换历史
        history = replace_history_manager.get_all_history()
        
        if not history:
            combo.addItem("无替换历史")
            return
            
        # 添加历史记录到下拉框
        for search_text, replace_text in history.items():
            combo.addItem(f"{search_text} → {replace_text}", userData=(search_text, replace_text))
    
    def on_history_selected(self, combo: QComboBox, search_input: QLineEdit, replace_input: QLineEdit):
        """当历史记录被选中时，更新输入框"""
        if combo.currentData() is None:
            return
            
        search_text, replace_text = combo.currentData()
        search_input.setText(search_text)
        replace_input.setText(replace_text)
    
    def apply_selected_history(self, combo: QComboBox):
        """应用选中的历史替换"""
        if combo.currentData() is None:
            return
            
        search_text, replace_text = combo.currentData()
        self.global_replace(search_text, replace_text)
    
    def remove_selected_history(self, combo: QComboBox):
        """删除选中的历史替换"""
        if combo.currentData() is None:
            return
            
        search_text, replace_text = combo.currentData()
        
        # 确认对话框
        reply = QMessageBox.question(
            self, 
            "确认删除", 
            f"确定要删除替换规则 '{search_text} → {replace_text}' 吗？",
            QMessageBox.Yes | QMessageBox.No, 
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            replace_history_manager.delete_replace_record(search_text)
            self.update_replace_history_combo(combo)
    
    def apply_all_history(self):
        """应用所有历史替换"""
        # 保存当前配置状态
        current_preset_selections = self._save_current_preset_selections()
        global_narration_preset = getattr(self, 'global_narration_preset', None)
        global_narration_emotion = getattr(self, 'global_narration_emotion', None)
        
        # 替换所有段落中的文本
        for i in range(len(self.segments)):
            self.segments[i] = replace_history_manager.apply_all_replacements(self.segments[i])
        
        # 清空现有内容，确保正确重新加载
        for i in reversed(range(self.content_layout.count())):
            widget = self.content_layout.itemAt(i).widget()
            if widget:
                widget.deleteLater()
        
        # 重新处理当前段落，这将使用analyze_text_segments重新识别对话
        self.process_current_segment()
        
        # 恢复全局预设和旁白配置
        self._restore_global_narration_preset(global_narration_preset, global_narration_emotion)
        
        QMessageBox.information(self, "成功", "已应用所有历史替换规则")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    app.setStyle('Fusion')  # 使用Fusion风格获得更现代的外观
    
    # 强制使用浅色主题
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor("#ffffff"))
    palette.setColor(QPalette.ColorRole.WindowText, QColor("#4a5568"))
    palette.setColor(QPalette.ColorRole.Base, QColor("#ffffff"))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor("#f7f7f7"))
    palette.setColor(QPalette.ColorRole.Text, QColor("#4a5568"))
    palette.setColor(QPalette.ColorRole.Button, QColor("#ffffff"))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor("#4a5568"))
    palette.setColor(QPalette.ColorRole.Highlight, QColor("#C5D8EC"))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor("#4a5568"))
    app.setPalette(palette)
    
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec()) 